From 33963cf2f14c72a60817f7d732bff2015f70f125 Mon Sep 17 00:00:00 2001
From: Jeremy Yang <jyang@cockroachlabs.com>
Date: Tue, 13 Feb 2024 13:35:35 -0800
Subject: [PATCH] remove bazel build files

---
 pkg/build/bazel/bazel.go                  | 146 -------
 pkg/build/bazel/non_bazel.go              |  67 ----
 pkg/build/bazel/util/tinystringer/main.go | 452 ----------------------
 3 files changed, 665 deletions(-)
 delete mode 100644 pkg/build/bazel/bazel.go
 delete mode 100644 pkg/build/bazel/non_bazel.go
 delete mode 100644 pkg/build/bazel/util/tinystringer/main.go

diff --git a/pkg/build/bazel/bazel.go b/pkg/build/bazel/bazel.go
deleted file mode 100644
index 2504468..0000000
--- a/pkg/build/bazel/bazel.go
+++ /dev/null
@@ -1,146 +0,0 @@
-// Copyright 2015 The Cockroach Authors.
-//
-// Use of this software is governed by the Business Source License
-// included in the file licenses/BSL.txt.
-//
-// As of the Change Date specified in that file, in accordance with
-// the Business Source License, use of this software will be governed
-// by the Apache License, Version 2.0, included in the file
-// licenses/APL.txt.
-
-//go:build bazel
-// +build bazel
-
-package bazel
-
-import (
-	"fmt"
-	"os"
-	"path"
-	"path/filepath"
-	"strconv"
-	"strings"
-
-	inner "github.com/bazelbuild/rules_go/go/tools/bazel"
-)
-
-// bazelTestEnvVar can be used to determine when running in the `bazel test`
-// environment.
-const bazelTestEnvVar = "BAZEL_TEST"
-
-// BuiltWithBazel returns true iff this library was built with Bazel.
-func BuiltWithBazel() bool {
-	return true
-}
-
-// InBazelTest returns true iff called from a test run by Bazel.
-func InBazelTest() bool {
-	if bazelTestEnv, ok := os.LookupEnv(bazelTestEnvVar); ok {
-		if bazelTest, err := strconv.ParseBool(bazelTestEnv); err == nil {
-			return bazelTest
-		}
-	}
-
-	return false
-}
-
-// InTestWrapper returns true iff called from Bazel's generated test wrapper.
-// When enabled and running under `bazel test`, the entire test runs using a
-// Bazel-generated wrapper. This wrapper imports the test module, so any
-// import-time code will be run twice: once under the wrapper, and once by the
-// test process itself. Hence, checking can be helpful for any module
-// import-time code, such as init() or any global variable initialization.
-// For more info, see:
-// https://github.com/bazelbuild/rules_go/blob/master/docs/go/core/rules.md#go_test
-//
-// Duplicates logic from rules_go's bzltestutil.ShouldWrap(), but does not
-// import in order to avoid a dependency (and its global initialization code).
-func InTestWrapper() bool {
-	if !InBazelTest() {
-		return false
-	}
-
-	if wrapEnv, ok := os.LookupEnv("GO_TEST_WRAP"); ok {
-		wrap, err := strconv.ParseBool(wrapEnv)
-		if err != nil {
-			return false
-		}
-		return wrap
-	}
-	_, ok := os.LookupEnv("XML_OUTPUT_FILE")
-	return ok
-}
-
-// FindBinary is a convenience wrapper around the rules_go variant.
-func FindBinary(pkg, name string) (string, bool) {
-	return inner.FindBinary(pkg, name)
-}
-
-// Runfile is a convenience wrapper around the rules_go variant.
-func Runfile(path string) (string, error) {
-	return inner.Runfile(path)
-}
-
-// RunfilesPath is a convenience wrapper around the rules_go variant.
-func RunfilesPath() (string, error) {
-	return inner.RunfilesPath()
-}
-
-// TestTmpDir is a convenience wrapper around the rules_go variant.
-func TestTmpDir() string {
-	return inner.TestTmpDir()
-}
-
-// NewTmpDir is a convenience wrapper around the rules_go variant.
-// The caller is responsible for cleaning the directory up after use.
-func NewTmpDir(prefix string) (string, error) {
-	return inner.NewTmpDir(prefix)
-}
-
-// Updates the current environment to use the Go toolchain that Bazel built this
-// binary/test with (updates the `PATH`/`GOROOT`/`GOCACHE` environment
-// variables).
-// If you want to use this function, your binary/test target MUST have
-// `@go_sdk//:files` in its `data` -- this will make sure the whole toolchain
-// gets pulled into the sandbox as well. Generally, this function should only
-// be called in init().
-func SetGoEnv() {
-	gobin, err := Runfile("bin/go")
-	if err != nil {
-		panic(err)
-	}
-	if err := os.Setenv("PATH", fmt.Sprintf("%s%c%s", filepath.Dir(gobin), os.PathListSeparator, os.Getenv("PATH"))); err != nil {
-		panic(err)
-	}
-	// GOPATH has to be set to some value (not equal to GOROOT) in order for `go env` to work.
-	// See https://github.com/golang/go/issues/43938 for the details.
-	// Specify a name under the system TEMP/TMP directory in order to be platform agnostic.
-	if err := os.Setenv("GOPATH", filepath.Join(os.TempDir(), "nonexist-gopath")); err != nil {
-		panic(err)
-	}
-	if err := os.Setenv("GOROOT", filepath.Dir(filepath.Dir(gobin))); err != nil {
-		panic(err)
-	}
-	if err := os.Setenv("GOCACHE", path.Join(inner.TestTmpDir(), ".gocache")); err != nil {
-		panic(err)
-	}
-}
-
-// Name of the environment variable containing the bazel target path
-// (//pkg/cmd/foo:bar).
-const testTargetEnv = "TEST_TARGET"
-
-// RelativeTestTargetPath returns relative path to the package
-// of the current test.
-func RelativeTestTargetPath() string {
-	target := os.Getenv(testTargetEnv)
-	if target == "" {
-		return ""
-	}
-
-	// Drop target name.
-	if last := strings.LastIndex(target, ":"); last > 0 {
-		target = target[:last]
-	}
-	return strings.TrimPrefix(target, "//")
-}
diff --git a/pkg/build/bazel/non_bazel.go b/pkg/build/bazel/non_bazel.go
deleted file mode 100644
index 17833fb..0000000
--- a/pkg/build/bazel/non_bazel.go
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright 2015 The Cockroach Authors.
-//
-// Use of this software is governed by the Business Source License
-// included in the file licenses/BSL.txt.
-//
-// As of the Change Date specified in that file, in accordance with
-// the Business Source License, use of this software will be governed
-// by the Apache License, Version 2.0, included in the file
-// licenses/APL.txt.
-
-//go:build !bazel
-// +build !bazel
-
-package bazel
-
-// This file contains stub implementations for non-bazel builds.
-// See bazel.go for full documentation on the contracts of these functions.
-
-// BuiltWithBazel returns true iff this library was built with Bazel.
-func BuiltWithBazel() bool {
-	return false
-}
-
-// InBazelTest returns true iff called from a test run by Bazel.
-func InBazelTest() bool {
-	return false
-}
-
-// InTestWrapper returns true iff called from Bazel's generated test wrapper.
-func InTestWrapper() bool {
-	return false
-}
-
-// FindBinary is not implemented.
-func FindBinary(pkg, name string) (string, bool) {
-	panic("not build with Bazel")
-}
-
-// Runfile is not implemented.
-func Runfile(string) (string, error) {
-	panic("not built with Bazel")
-}
-
-// RunfilesPath is not implemented.
-func RunfilesPath() (string, error) {
-	panic("not built with Bazel")
-}
-
-// TestTmpDir is not implemented.
-func TestTmpDir() string {
-	panic("not built with Bazel")
-}
-
-// NewTmpDir is not implemented.
-func NewTmpDir(prefix string) (string, error) {
-	panic("not built with Bazel")
-}
-
-// RelativeTestTargetPath is not implemented.
-func RelativeTestTargetPath() string {
-	panic("not built with Bazel")
-}
-
-// SetGoEnv is not implemented.
-func SetGoEnv() {
-	panic("not built with Bazel")
-}
diff --git a/pkg/build/bazel/util/tinystringer/main.go b/pkg/build/bazel/util/tinystringer/main.go
deleted file mode 100644
index b0b260a..0000000
--- a/pkg/build/bazel/util/tinystringer/main.go
+++ /dev/null
@@ -1,452 +0,0 @@
-// Copyright 2023 The Cockroach Authors.
-//
-// Use of this software is governed by the Business Source License
-// included in the file licenses/BSL.txt.
-//
-// As of the Change Date specified in that file, in accordance with
-// the Business Source License, use of this software will be governed
-// by the Apache License, Version 2.0, included in the file
-// licenses/APL.txt.
-
-package main
-
-import (
-	"errors"
-	"flag"
-	"fmt"
-	"go/ast"
-	"go/parser"
-	"go/token"
-	"os"
-	"path/filepath"
-	"sort"
-	"strconv"
-	"strings"
-)
-
-var (
-	lineComment                                                             bool
-	output, typeName, trimPrefix, stringToValueMapName, enumValuesSliceName string
-	allowedIntegerTypes                                                     = []string{
-		"byte",
-		"int",
-		"int8",
-		"int16",
-		"int32",
-		"int64",
-		"rune",
-		"uint",
-		"uint8",
-		"uint16",
-		"uint32",
-		"uint64",
-	}
-)
-
-type tinyStringer struct {
-	files                                                                   []string
-	typeName, trimPrefix, output, stringToValueMapName, enumValuesSliceName string
-	lineComment                                                             bool
-}
-
-func init() {
-	flag.StringVar(&stringToValueMapName, "stringtovaluemapname", "", "if set, also create a map of enum name -> value of the given name")
-	flag.StringVar(&enumValuesSliceName, "enumvaluesslicename", "", "if set, also create a slice of all enum values of the given name")
-	flag.StringVar(&output, "output", "", "name of output file; default srcdir/<type>_string.go")
-	flag.StringVar(&typeName, "type", "", "the type for which to generate output")
-	flag.StringVar(&trimPrefix, "trimprefix", "", "trim the given prefix from generated names")
-	flag.BoolVar(&lineComment, "linecomment", false, "use line comment text as printed text when present")
-}
-
-func main() {
-	flag.Parse()
-	if err := doMain(); err != nil {
-		panic(err)
-	}
-}
-
-func doMain() error {
-	if typeName == "" {
-		return errors.New("must provide --type")
-	}
-	return tinyStringer{
-		enumValuesSliceName:  enumValuesSliceName,
-		files:                flag.Args(),
-		lineComment:          lineComment,
-		output:               output,
-		stringToValueMapName: stringToValueMapName,
-		typeName:             typeName,
-		trimPrefix:           trimPrefix,
-	}.stringify()
-}
-
-func (s tinyStringer) stringify() error {
-	if len(s.files) == 0 {
-		return errors.New("must provide at least one file argument")
-	}
-	// Make sure all input files are in the same package.
-	var srcDir, whichFile string
-	for _, file := range s.files {
-		dir := filepath.Dir(file)
-		if srcDir == "" {
-			srcDir = dir
-			whichFile = file
-		} else {
-			if srcDir != dir {
-				return fmt.Errorf("all input files must be in the same source directory; got input file %s in directory %s, but input file %s in directory %s", whichFile, srcDir, file, dir)
-			}
-		}
-	}
-	if s.output == "" {
-		s.output = filepath.Join(srcDir, strings.ToLower(s.typeName)+"_string.go")
-	}
-
-	parsedFiles, pkgName, err := parseAllFiles(s.files)
-	if err != nil {
-		return err
-	}
-	if err := validateType(parsedFiles, s.typeName); err != nil {
-		return err
-	}
-
-	inOrder, nameToInt, nameToPrinted, err := s.computeConstantValues(parsedFiles)
-	if err != nil {
-		return err
-	}
-
-	if len(nameToInt) == 0 || len(nameToPrinted) == 0 {
-		return fmt.Errorf("did not find enough constant values for type %s", s.typeName)
-	}
-
-	// Produce s.output.
-	outputFile, err := os.Create(s.output)
-	if err != nil {
-		return err
-	}
-	defer func() {
-		_ = outputFile.Close()
-	}()
-	fmt.Fprintf(outputFile, `// Code generated by "stringer"; DO NOT EDIT.
-
-package %s
-
-import "strconv"
-
-func _() {
-	// An "invalid array index" compiler error signifies that the constant values have changed.
-	// Re-run the stringer command to generate them again.
-	var x [1]struct{}
-`, pkgName)
-	for _, constName := range inOrder {
-		if constName == "_" {
-			continue
-		}
-		minus := "-"
-		if nameToInt[constName] < 0 {
-			// Implement the behavior of gofmt, which wants no space
-			// between the operands unless the number on the right
-			// is negative (would probably trigger some parse error).
-			minus = " - "
-		}
-		fmt.Fprintf(outputFile, "	_ = x[%s%s%d]\n", constName, minus, nameToInt[constName])
-	}
-	receiverVar := "i"
-	if _, ok := nameToInt[receiverVar]; ok {
-		receiverVar = "_i"
-		if _, ok := nameToInt[receiverVar]; ok {
-			return fmt.Errorf("don't know how to choose a receiver variable because %s is a constant name", receiverVar)
-		}
-	}
-	fmt.Fprintf(outputFile, `}
-
-func (%s %s) String() string {
-	switch %s {
-`, receiverVar, s.typeName, receiverVar)
-	seen := make(map[int]struct{})
-	for _, constName := range inOrder {
-		if constName == "_" {
-			continue
-		}
-		if _, ok := seen[nameToInt[constName]]; ok {
-			continue
-		}
-		fmt.Fprintf(outputFile, `	case %s:
-		return "%s"
-`, constName, nameToPrinted[constName])
-		seen[nameToInt[constName]] = struct{}{}
-	}
-	fmt.Fprintf(outputFile, `	default:
-		return "%s(" + strconv.FormatInt(int64(i), 10) + ")"
-	}
-}
-`, s.typeName)
-	if s.stringToValueMapName != "" {
-		fmt.Fprintf(outputFile, `
-var %s = map[string]%s{
-`, s.stringToValueMapName, s.typeName)
-		// Figure out the length of the longest const name to see how
-		// much we need to pad it out.
-		var maxLen int
-		for _, constName := range inOrder {
-			if len(nameToPrinted[constName]) > maxLen {
-				maxLen = len(nameToPrinted[constName])
-			}
-		}
-		for _, constName := range inOrder {
-			if constName == "_" {
-				continue
-			}
-			padding := strings.Repeat(" ", 1+maxLen-len(nameToPrinted[constName]))
-			fmt.Fprintf(outputFile, `	"%s":%s%d,
-`, nameToPrinted[constName], padding, nameToInt[constName])
-		}
-		fmt.Fprintf(outputFile, `}
-`)
-	}
-	if s.enumValuesSliceName != "" {
-		seen := make(map[int]struct{})
-		fmt.Fprintf(outputFile, `
-var %s = []%s{
-`, s.enumValuesSliceName, s.typeName)
-		inLexicographicOrder := make([]string, len(inOrder))
-		copy(inLexicographicOrder, inOrder)
-		// Clear duplicates, select the first one in order.
-		i := 0
-		for i < len(inLexicographicOrder) {
-			constName := inLexicographicOrder[i]
-			if _, ok := seen[nameToInt[constName]]; ok {
-				inLexicographicOrder = append(inLexicographicOrder[:i], inLexicographicOrder[i+1:]...)
-			} else {
-				i += 1
-				seen[nameToInt[constName]] = struct{}{}
-			}
-		}
-		sort.Slice(inLexicographicOrder, func(i, j int) bool {
-			return nameToPrinted[inLexicographicOrder[i]] < nameToPrinted[inLexicographicOrder[j]]
-		})
-		seen = make(map[int]struct{})
-		for _, constName := range inLexicographicOrder {
-			if constName == "_" {
-				continue
-			}
-			if _, ok := seen[nameToInt[constName]]; ok {
-				continue
-			}
-			fmt.Fprintf(outputFile, `	%s,
-`, constName)
-			seen[nameToInt[constName]] = struct{}{}
-		}
-		fmt.Fprintf(outputFile, `}
-`)
-	}
-
-	return nil
-}
-
-// parseAllFiles returns a list of all the files parsed, the name of the package, and an error if one occurred.
-func parseAllFiles(files []string) ([]*ast.File, string, error) {
-	// Parse all files.
-	fset := token.NewFileSet()
-	parsedFiles := make([]*ast.File, 0, len(files))
-	for _, file := range files {
-		parsed, err := parser.ParseFile(fset, file, nil, parser.SkipObjectResolution|parser.ParseComments)
-		if err != nil {
-			return nil, "", err
-		}
-		parsedFiles = append(parsedFiles, parsed)
-	}
-	// All files should have the same package declaration. This will help us
-	// determine what package the generated file should be in.
-	var pkgName, whichFile string
-	for i, file := range parsedFiles {
-		if pkgName == "" {
-			pkgName = file.Name.Name
-			whichFile = files[i]
-		} else {
-			if pkgName != file.Name.Name {
-				return nil, "", fmt.Errorf("all input files must have the same package name; got input file %s w/ 'package %s', but input file %s w/ 'package %s'", whichFile, pkgName, files[i], file.Name.Name)
-			}
-		}
-	}
-	return parsedFiles, pkgName, nil
-}
-
-func validateType(files []*ast.File, typeName string) error {
-	// Find the definition of the type. Should be an alias for some
-	// integer type.
-	for _, file := range files {
-		for _, decl := range file.Decls {
-			var genDecl *ast.GenDecl
-			genDecl, ok := decl.(*ast.GenDecl)
-			if !ok {
-				continue
-			}
-			if genDecl.Tok != token.TYPE {
-				continue
-			}
-			for _, spec := range genDecl.Specs {
-				typeSpec, ok := spec.(*ast.TypeSpec)
-				if !ok {
-					// Should never happen.
-					return fmt.Errorf("unexpected error occurred while processing %+v", spec)
-				}
-				if typeSpec.Name.Name != typeName {
-					continue
-				}
-				// Ensure the type is an alias for a built-in integer type.
-				ident, ok := typeSpec.Type.(*ast.Ident)
-				if !ok {
-					return fmt.Errorf("expected identifier for definition of type %s", typeName)
-				}
-				var found bool
-				for _, intType := range allowedIntegerTypes {
-					if ident.Name == intType {
-						found = true
-						break
-					}
-
-				}
-				if !found {
-					return fmt.Errorf("expected an integer type for definition of type %s; got %s", typeName, ident.Name)
-				}
-			}
-		}
-	}
-	return nil
-}
-
-func (s tinyStringer) computeConstantValues(
-	files []*ast.File,
-) (inOrder []string, nameToInt map[string]int, nameToPrinted map[string]string, err error) {
-	nameToInt = make(map[string]int)
-	nameToPrinted = make(map[string]string)
-
-	for _, file := range files {
-		for _, decl := range file.Decls {
-			var genDecl *ast.GenDecl
-			genDecl, ok := decl.(*ast.GenDecl)
-			if !ok {
-				continue
-			}
-			if genDecl.Tok != token.CONST {
-				continue
-			}
-			var inferAppropriateType, inIota bool
-			var iotaVal int
-			for _, spec := range genDecl.Specs {
-				valueSpec, ok := spec.(*ast.ValueSpec)
-				if !ok {
-					// Should never happen.
-					err = fmt.Errorf("unexpected error occurred while processing %+v", spec)
-					return
-				}
-				if valueSpec.Type == nil && !inferAppropriateType {
-					continue
-				}
-				ident, ok := valueSpec.Type.(*ast.Ident)
-				if (ok && ident.Name != s.typeName) || (!ok && !inferAppropriateType) {
-					inferAppropriateType = false
-					continue
-				}
-				inferAppropriateType = true
-				if len(valueSpec.Names) != 1 {
-					err = fmt.Errorf("expected one name for constant of type %s; found %+v", s.typeName, valueSpec.Names)
-					return
-				}
-				constName := valueSpec.Names[0].Name
-				inOrder = append(inOrder, constName)
-				// Check the value to see what value we'll assign to the constant.
-				if valueSpec.Values == nil {
-					if inIota {
-						nameToInt[constName] = iotaVal
-						iotaVal += 1
-					} else {
-						nameToInt[constName] = 0
-					}
-				} else if len(valueSpec.Values) != 1 {
-					err = fmt.Errorf("expected one value for constant %s; found %+v", constName, valueSpec.Values)
-					return
-				} else if lit, ok := valueSpec.Values[0].(*ast.BasicLit); ok {
-					if lit.Kind == token.INT {
-						var intVal int64
-						intVal, err = strconv.ParseInt(lit.Value, 0, 0)
-						if err != nil {
-							return
-						}
-						nameToInt[constName] = int(intVal)
-						inIota = false
-					} else if lit.Kind == token.CHAR {
-						if len(lit.Value) != 3 {
-							err = fmt.Errorf("expected string of form 'X' for character: got %s", lit.Value)
-							return
-						}
-						if lit.Value[0] != '\'' || lit.Value[2] != '\'' {
-							err = fmt.Errorf("expected string of form 'X' for character: got %s", lit.Value)
-							return
-						}
-						nameToInt[constName] = int(lit.Value[1])
-						inIota = false
-					} else {
-						err = fmt.Errorf("expected integer value for constant %s; found %s", constName, lit.Value)
-						return
-					}
-				} else if ident, ok := valueSpec.Values[0].(*ast.Ident); ok {
-					if ident.Name == "iota" {
-						inIota = true
-						nameToInt[constName] = iotaVal
-						iotaVal += 1
-					} else if otherValue, ok := nameToInt[ident.Name]; ok {
-						nameToInt[constName] = otherValue
-						inIota = false
-					}
-				} else if binExpr, ok := valueSpec.Values[0].(*ast.BinaryExpr); ok {
-					// Handle iota + N or iota - N.
-					iotaIdent, ok := binExpr.X.(*ast.Ident)
-					if !ok || iotaIdent.Name != "iota" {
-						err = fmt.Errorf("expected 'iota' in binary expression %+v; found %+v", binExpr, binExpr.X)
-						return
-					}
-					var otherNumParsed int64
-					if otherNum, ok := binExpr.Y.(*ast.BasicLit); ok && otherNum.Kind == token.INT {
-						otherNumParsed, err = strconv.ParseInt(otherNum.Value, 0, 0)
-						if err != nil {
-							return
-						}
-					} else if otherRef, ok := binExpr.Y.(*ast.Ident); ok {
-						otherNum, ok := nameToInt[otherRef.Name]
-						if !ok {
-							err = fmt.Errorf("could not find value of %s", otherRef.Name)
-							return
-						}
-						otherNumParsed = int64(otherNum)
-					} else {
-						err = fmt.Errorf("couldn't parse second argument of binary expression %+v; found %+v", binExpr, binExpr.Y)
-						return
-					}
-					if binExpr.Op == token.ADD {
-						iotaVal = iotaVal + int(otherNumParsed)
-					} else if binExpr.Op == token.SUB {
-						iotaVal = iotaVal - int(otherNumParsed)
-					}
-					inIota = true
-					nameToInt[constName] = iotaVal
-					iotaVal += 1
-				} else {
-					err = fmt.Errorf("don't know how to process %+v", valueSpec.Values[0])
-					return
-				}
-
-				// Determine the printed name of the constant.
-				printedName := constName
-				if s.lineComment && valueSpec.Comment != nil {
-					printedName = strings.TrimSpace(valueSpec.Comment.Text())
-				}
-				if s.trimPrefix != "" {
-					printedName = strings.TrimPrefix(printedName, s.trimPrefix)
-				}
-				nameToPrinted[constName] = printedName
-			}
-		}
-	}
-	return
-}
-- 
2.38.1

