From 6f5dc3ecb62864562a1a715962e4c70d0e19c91e Mon Sep 17 00:00:00 2001
From: Jeremy Yang <jyang@cockroachlabs.com>
Date: Mon, 12 Feb 2024 13:19:27 -0800
Subject: [PATCH] delete plpgsql files

---
 pkg/sql/plpgsql/parser/lexbase/keywords.go |  356 -----
 pkg/sql/plpgsql/parser/lexbase/tokens.go   |  134 --
 pkg/sql/plpgsql/parser/lexbase/utils.go    |   12 -
 pkg/sql/plpgsql/parser/lexer.go            |  501 ------
 pkg/sql/plpgsql/parser/parse.go            |  136 --
 pkg/sql/plpgsql/parser/plpgsql.y           | 1647 --------------------
 pkg/sql/scanner/plpgsql_scan.go            |  246 ---
 7 files changed, 3032 deletions(-)
 delete mode 100644 pkg/sql/plpgsql/parser/lexbase/keywords.go
 delete mode 100644 pkg/sql/plpgsql/parser/lexbase/tokens.go
 delete mode 100644 pkg/sql/plpgsql/parser/lexbase/utils.go
 delete mode 100644 pkg/sql/plpgsql/parser/lexer.go
 delete mode 100644 pkg/sql/plpgsql/parser/parse.go
 delete mode 100644 pkg/sql/plpgsql/parser/plpgsql.y
 delete mode 100644 pkg/sql/scanner/plpgsql_scan.go

diff --git a/pkg/sql/plpgsql/parser/lexbase/keywords.go b/pkg/sql/plpgsql/parser/lexbase/keywords.go
deleted file mode 100644
index 8cd3bc1..0000000
--- a/pkg/sql/plpgsql/parser/lexbase/keywords.go
+++ /dev/null
@@ -1,356 +0,0 @@
-// Code generated by pkg/sql/lexbase/allkeywords. DO NOT EDIT.
-
-package lexbase
-
-var KeywordsCategories = map[string]string{
-"absolute": "U",
-"alias": "U",
-"all": "R",
-"and": "U",
-"array": "U",
-"assert": "U",
-"backward": "U",
-"begin": "R",
-"by": "R",
-"call": "U",
-"case": "R",
-"chain": "U",
-"close": "U",
-"collate": "U",
-"column": "U",
-"column_name": "U",
-"commit": "U",
-"constant": "U",
-"constraint": "U",
-"constraint_name": "U",
-"continue": "U",
-"current": "U",
-"cursor": "U",
-"datatype": "U",
-"debug": "U",
-"declare": "R",
-"default": "U",
-"detail": "U",
-"diagnostics": "U",
-"do": "U",
-"dump": "U",
-"else": "R",
-"elsif": "U",
-"end": "R",
-"end_case": "R",
-"end_if": "R",
-"errcode": "U",
-"error": "U",
-"exception": "U",
-"execute": "R",
-"exit": "U",
-"fetch": "U",
-"first": "U",
-"for": "R",
-"foreach": "R",
-"forward": "U",
-"from": "R",
-"get": "U",
-"hint": "U",
-"if": "R",
-"import": "U",
-"in": "R",
-"info": "U",
-"insert": "U",
-"into": "R",
-"is": "U",
-"last": "U",
-"log": "U",
-"loop": "R",
-"merge": "U",
-"message": "U",
-"message_text": "U",
-"move": "U",
-"next": "U",
-"no": "U",
-"not": "R",
-"notice": "U",
-"no_scroll": "U",
-"null": "R",
-"open": "U",
-"option": "U",
-"or": "R",
-"perform": "U",
-"pg_context": "U",
-"pg_datatype_name": "U",
-"pg_exception_context": "U",
-"pg_exception_detail": "U",
-"pg_exception_hint": "U",
-"print_strict_params": "U",
-"prior": "U",
-"query": "U",
-"raise": "U",
-"relative": "U",
-"return": "U",
-"returned_sqlstate": "U",
-"return_next": "U",
-"return_query": "U",
-"reverse": "U",
-"rollback": "U",
-"rowtype": "U",
-"row_count": "U",
-"schema": "U",
-"schema_name": "U",
-"scroll": "U",
-"slice": "U",
-"sqlstate": "U",
-"stacked": "U",
-"strict": "R",
-"table": "U",
-"table_name": "U",
-"then": "R",
-"to": "R",
-"type": "U",
-"upsert": "U",
-"use_column": "U",
-"use_variable": "U",
-"using": "R",
-"variable_conflict": "U",
-"warning": "U",
-"when": "R",
-"while": "R",
-}
-
-// KeywordNames contains all keywords sorted, so that pg_get_keywords returns
-// deterministic results.
-var KeywordNames = []string{
-"absolute",
-"alias",
-"all",
-"and",
-"array",
-"assert",
-"backward",
-"begin",
-"by",
-"call",
-"case",
-"chain",
-"close",
-"collate",
-"column",
-"column_name",
-"commit",
-"constant",
-"constraint",
-"constraint_name",
-"continue",
-"current",
-"cursor",
-"datatype",
-"debug",
-"declare",
-"default",
-"detail",
-"diagnostics",
-"do",
-"dump",
-"else",
-"elsif",
-"end",
-"end_case",
-"end_if",
-"errcode",
-"error",
-"exception",
-"execute",
-"exit",
-"fetch",
-"first",
-"for",
-"foreach",
-"forward",
-"from",
-"get",
-"hint",
-"if",
-"import",
-"in",
-"info",
-"insert",
-"into",
-"is",
-"last",
-"log",
-"loop",
-"merge",
-"message",
-"message_text",
-"move",
-"next",
-"no",
-"not",
-"notice",
-"no_scroll",
-"null",
-"open",
-"option",
-"or",
-"perform",
-"pg_context",
-"pg_datatype_name",
-"pg_exception_context",
-"pg_exception_detail",
-"pg_exception_hint",
-"print_strict_params",
-"prior",
-"query",
-"raise",
-"relative",
-"return",
-"returned_sqlstate",
-"return_next",
-"return_query",
-"reverse",
-"rollback",
-"rowtype",
-"row_count",
-"schema",
-"schema_name",
-"scroll",
-"slice",
-"sqlstate",
-"stacked",
-"strict",
-"table",
-"table_name",
-"then",
-"to",
-"type",
-"upsert",
-"use_column",
-"use_variable",
-"using",
-"variable_conflict",
-"warning",
-"when",
-"while",
-}
-
-// GetKeywordID returns the lex id of the SQL keyword k or IDENT if k is
-// not a keyword.
-func GetKeywordID(k string) int32 {
-	// The previous implementation generated a map that did a string ->
-	// id lookup. Various ideas were benchmarked and the implementation below
-	// was the fastest of those, between 3% and 10% faster (at parsing, so the
-	// scanning speedup is even more) than the map implementation.
-	switch k {
-	case "absolute": return ABSOLUTE
-	case "alias": return ALIAS
-	case "all": return ALL
-	case "and": return AND
-	case "array": return ARRAY
-	case "assert": return ASSERT
-	case "backward": return BACKWARD
-	case "begin": return BEGIN
-	case "by": return BY
-	case "call": return CALL
-	case "case": return CASE
-	case "chain": return CHAIN
-	case "close": return CLOSE
-	case "collate": return COLLATE
-	case "column": return COLUMN
-	case "column_name": return COLUMN_NAME
-	case "commit": return COMMIT
-	case "constant": return CONSTANT
-	case "constraint": return CONSTRAINT
-	case "constraint_name": return CONSTRAINT_NAME
-	case "continue": return CONTINUE
-	case "current": return CURRENT
-	case "cursor": return CURSOR
-	case "datatype": return DATATYPE
-	case "debug": return DEBUG
-	case "declare": return DECLARE
-	case "default": return DEFAULT
-	case "detail": return DETAIL
-	case "diagnostics": return DIAGNOSTICS
-	case "do": return DO
-	case "dump": return DUMP
-	case "else": return ELSE
-	case "elsif": return ELSIF
-	case "end": return END
-	case "end_case": return END_CASE
-	case "end_if": return END_IF
-	case "errcode": return ERRCODE
-	case "error": return ERROR
-	case "exception": return EXCEPTION
-	case "execute": return EXECUTE
-	case "exit": return EXIT
-	case "fetch": return FETCH
-	case "first": return FIRST
-	case "for": return FOR
-	case "foreach": return FOREACH
-	case "forward": return FORWARD
-	case "from": return FROM
-	case "get": return GET
-	case "hint": return HINT
-	case "if": return IF
-	case "import": return IMPORT
-	case "in": return IN
-	case "info": return INFO
-	case "insert": return INSERT
-	case "into": return INTO
-	case "is": return IS
-	case "last": return LAST
-	case "log": return LOG
-	case "loop": return LOOP
-	case "merge": return MERGE
-	case "message": return MESSAGE
-	case "message_text": return MESSAGE_TEXT
-	case "move": return MOVE
-	case "next": return NEXT
-	case "no": return NO
-	case "not": return NOT
-	case "notice": return NOTICE
-	case "no_scroll": return NO_SCROLL
-	case "null": return NULL
-	case "open": return OPEN
-	case "option": return OPTION
-	case "or": return OR
-	case "perform": return PERFORM
-	case "pg_context": return PG_CONTEXT
-	case "pg_datatype_name": return PG_DATATYPE_NAME
-	case "pg_exception_context": return PG_EXCEPTION_CONTEXT
-	case "pg_exception_detail": return PG_EXCEPTION_DETAIL
-	case "pg_exception_hint": return PG_EXCEPTION_HINT
-	case "print_strict_params": return PRINT_STRICT_PARAMS
-	case "prior": return PRIOR
-	case "query": return QUERY
-	case "raise": return RAISE
-	case "relative": return RELATIVE
-	case "return": return RETURN
-	case "returned_sqlstate": return RETURNED_SQLSTATE
-	case "return_next": return RETURN_NEXT
-	case "return_query": return RETURN_QUERY
-	case "reverse": return REVERSE
-	case "rollback": return ROLLBACK
-	case "rowtype": return ROWTYPE
-	case "row_count": return ROW_COUNT
-	case "schema": return SCHEMA
-	case "schema_name": return SCHEMA_NAME
-	case "scroll": return SCROLL
-	case "slice": return SLICE
-	case "sqlstate": return SQLSTATE
-	case "stacked": return STACKED
-	case "strict": return STRICT
-	case "table": return TABLE
-	case "table_name": return TABLE_NAME
-	case "then": return THEN
-	case "to": return TO
-	case "type": return TYPE
-	case "upsert": return UPSERT
-	case "use_column": return USE_COLUMN
-	case "use_variable": return USE_VARIABLE
-	case "using": return USING
-	case "variable_conflict": return VARIABLE_CONFLICT
-	case "warning": return WARNING
-	case "when": return WHEN
-	case "while": return WHILE
-	default: return IDENT
-	}
-}
diff --git a/pkg/sql/plpgsql/parser/lexbase/tokens.go b/pkg/sql/plpgsql/parser/lexbase/tokens.go
deleted file mode 100644
index 56ac04c..0000000
--- a/pkg/sql/plpgsql/parser/lexbase/tokens.go
+++ /dev/null
@@ -1,134 +0,0 @@
-// Code generated by make. DO NOT EDIT.
-// GENERATED FILE DO NOT EDIT
-
-package lexbase
-
-const IDENT = 57346
-const UIDENT = 57347
-const FCONST = 57348
-const SCONST = 57349
-const USCONST = 57350
-const BCONST = 57351
-const XCONST = 57352
-const ICONST = 57354
-const PARAM = 57355
-const TYPECAST = 57356
-const DOT_DOT = 57357
-const COLON_EQUALS = 57358
-const EQUALS_GREATER = 57359
-const LESS_EQUALS = 57360
-const GREATER_EQUALS = 57361
-const NOT_EQUALS = 57362
-const LESS_LESS = 57363
-const GREATER_GREATER = 57364
-const ABSOLUTE = 57365
-const ALIAS = 57366
-const ALL = 57367
-const AND = 57368
-const ARRAY = 57369
-const ASSERT = 57370
-const BACKWARD = 57371
-const BEGIN = 57372
-const BY = 57373
-const CALL = 57374
-const CASE = 57375
-const CHAIN = 57376
-const CLOSE = 57377
-const COLLATE = 57378
-const COLUMN = 57379
-const COLUMN_NAME = 57380
-const COMMIT = 57381
-const CONSTANT = 57382
-const CONSTRAINT = 57383
-const CONSTRAINT_NAME = 57384
-const CONTINUE = 57385
-const CURRENT = 57386
-const CURSOR = 57387
-const DATATYPE = 57388
-const DEBUG = 57389
-const DECLARE = 57390
-const DEFAULT = 57391
-const DETAIL = 57392
-const DIAGNOSTICS = 57393
-const DO = 57394
-const DUMP = 57395
-const ELSE = 57396
-const ELSIF = 57397
-const END = 57398
-const END_CASE = 57399
-const END_IF = 57400
-const ERRCODE = 57401
-const ERROR = 57402
-const EXCEPTION = 57403
-const EXECUTE = 57404
-const EXIT = 57405
-const FETCH = 57406
-const FIRST = 57407
-const FOR = 57408
-const FOREACH = 57409
-const FORWARD = 57410
-const FROM = 57411
-const GET = 57412
-const HINT = 57413
-const IF = 57414
-const IMPORT = 57415
-const IN = 57416
-const INFO = 57417
-const INSERT = 57418
-const INTO = 57419
-const IS = 57420
-const LAST = 57421
-const LOG = 57422
-const LOOP = 57423
-const MERGE = 57424
-const MESSAGE = 57425
-const MESSAGE_TEXT = 57426
-const MOVE = 57427
-const NEXT = 57428
-const NO = 57429
-const NO_SCROLL = 57430
-const NOT = 57431
-const NOTICE = 57432
-const NULL = 57433
-const OPEN = 57434
-const OPTION = 57435
-const OR = 57436
-const PERFORM = 57437
-const PG_CONTEXT = 57438
-const PG_DATATYPE_NAME = 57439
-const PG_EXCEPTION_CONTEXT = 57440
-const PG_EXCEPTION_DETAIL = 57441
-const PG_EXCEPTION_HINT = 57442
-const PRINT_STRICT_PARAMS = 57443
-const PRIOR = 57444
-const QUERY = 57445
-const RAISE = 57446
-const RELATIVE = 57447
-const RETURN = 57448
-const RETURN_NEXT = 57449
-const RETURN_QUERY = 57450
-const RETURNED_SQLSTATE = 57451
-const REVERSE = 57452
-const ROLLBACK = 57453
-const ROW_COUNT = 57454
-const ROWTYPE = 57455
-const SCHEMA = 57456
-const SCHEMA_NAME = 57457
-const SCROLL = 57458
-const SLICE = 57459
-const SQLSTATE = 57460
-const STACKED = 57461
-const STRICT = 57462
-const TABLE = 57463
-const TABLE_NAME = 57464
-const THEN = 57465
-const TO = 57466
-const TYPE = 57467
-const UPSERT = 57468
-const USE_COLUMN = 57469
-const USE_VARIABLE = 57470
-const USING = 57471
-const VARIABLE_CONFLICT = 57472
-const WARNING = 57473
-const WHEN = 57474
-const WHILE = 57475
diff --git a/pkg/sql/plpgsql/parser/lexbase/utils.go b/pkg/sql/plpgsql/parser/lexbase/utils.go
deleted file mode 100644
index 66596bf..0000000
--- a/pkg/sql/plpgsql/parser/lexbase/utils.go
+++ /dev/null
@@ -1,12 +0,0 @@
-// Copyright 2023 The Cockroach Authors.
-//
-// Use of this software is governed by the Business Source License
-// included in the file licenses/BSL.txt.
-//
-// As of the Change Date specified in that file, in accordance with
-// the Business Source License, use of this software will be governed
-// by the Apache License, Version 2.0, included in the file
-// licenses/APL.txt.
-
-// Package lexbase contains utilities for lexing plpgsql.
-package lexbase
diff --git a/pkg/sql/plpgsql/parser/lexer.go b/pkg/sql/plpgsql/parser/lexer.go
deleted file mode 100644
index 9201b03..0000000
--- a/pkg/sql/plpgsql/parser/lexer.go
+++ /dev/null
@@ -1,501 +0,0 @@
-// Copyright 2023 The Cockroach Authors.
-//
-// Use of this software is governed by the Business Source License
-// included in the file licenses/BSL.txt.
-//
-// As of the Change Date specified in that file, in accordance with
-// the Business Source License, use of this software will be governed
-// by the Apache License, Version 2.0, included in the file
-// licenses/APL.txt.
-
-package parser
-
-import (
-	"strings"
-
-	"github.com/cockroachdb/cockroachdb-parser/pkg/sql/parser"
-	"github.com/cockroachdb/cockroachdb-parser/pkg/sql/pgwire/pgcode"
-	"github.com/cockroachdb/cockroachdb-parser/pkg/sql/pgwire/pgerror"
-	"github.com/cockroachdb/cockroachdb-parser/pkg/sql/sem/plpgsqltree"
-	"github.com/cockroachdb/cockroachdb-parser/pkg/sql/sem/tree"
-	"github.com/cockroachdb/cockroachdb-parser/pkg/sql/types"
-	unimp "github.com/cockroachdb/cockroachdb-parser/pkg/util/errorutil/unimplemented"
-	"github.com/cockroachdb/errors"
-)
-
-type lexer struct {
-	in string
-	// tokens contains tokens generated by the scanner.
-	tokens []plpgsqlSymType
-
-	// The type that should be used when an INT or SERIAL is encountered.
-	nakedIntType *types.T
-
-	// lastPos is the position into the tokens slice of the last
-	// token returned by Lex().
-	lastPos int
-
-	stmt *plpgsqltree.Block
-
-	// numPlaceholders is 1 + the highest placeholder index encountered.
-	numPlaceholders int
-	numAnnotations  tree.AnnotationIdx
-
-	lastError error
-
-	parser plpgsqlParser
-}
-
-func (l *lexer) init(sql string, tokens []plpgsqlSymType, nakedIntType *types.T, p plpgsqlParser) {
-	l.in = sql
-	l.tokens = tokens
-	l.lastPos = -1
-	l.stmt = nil
-	l.numPlaceholders = 0
-	l.numAnnotations = 0
-	l.lastError = nil
-	l.nakedIntType = nakedIntType
-	l.parser = p
-}
-
-// cleanup is used to avoid holding on to memory unnecessarily (for the cases
-// where we reuse a scanner).
-func (l *lexer) cleanup() {
-	l.tokens = nil
-	l.stmt = nil
-	l.lastError = nil
-}
-
-// Lex lexes a token from input.
-// to push the tokens back (move l.pos back).
-func (l *lexer) Lex(lval *plpgsqlSymType) int {
-	l.lastPos++
-	// The core lexing takes place in the scanner. Here we do a small bit of post
-	// processing of the lexical tokens so that the grammar only requires
-	// one-token lookahead despite SQL requiring multi-token lookahead in some
-	// cases. These special cases are handled below and the returned tokens are
-	// adjusted to reflect the lookahead (LA) that occurred.
-	if l.lastPos >= len(l.tokens) {
-		lval.id = 0
-		lval.pos = int32(len(l.in))
-		lval.str = "EOF"
-		return 0
-	}
-	*lval = l.tokens[l.lastPos]
-
-	switch lval.id {
-	case RETURN:
-		nextToken := plpgsqlSymType{}
-		if l.lastPos+1 < len(l.tokens) {
-			nextToken = l.tokens[l.lastPos+1]
-		}
-		switch nextToken.id {
-		case NEXT:
-			lval.id = RETURN_NEXT
-		case QUERY:
-			lval.id = RETURN_QUERY
-		}
-	case END:
-		nextToken := plpgsqlSymType{}
-		if l.lastPos+1 < len(l.tokens) {
-			nextToken = l.tokens[l.lastPos+1]
-		}
-		switch nextToken.id {
-		case IF:
-			lval.id = END_IF
-		case CASE:
-			lval.id = END_CASE
-		}
-	case NO:
-		nextToken := plpgsqlSymType{}
-		if l.lastPos+1 < len(l.tokens) {
-			nextToken = l.tokens[l.lastPos+1]
-		}
-		switch nextToken.id {
-		case SCROLL:
-			lval.id = NO_SCROLL
-		}
-	}
-
-	return int(lval.id)
-}
-
-// MakeExecSqlStmt makes an Execute node.
-func (l *lexer) MakeExecSqlStmt() (*plpgsqltree.Execute, error) {
-	if l.parser.Lookahead() != -1 {
-		// Push back the lookahead token so that it can be included.
-		l.PushBack(1)
-	}
-	// Push back the first token so that it's included in the SQL string.
-	l.PushBack(1)
-	startPos, endPos, _, err := l.readSQLConstruct(false /* isExpr */, ';')
-	if err != nil {
-		return nil, err
-	}
-	// Move past the semicolon.
-	l.lastPos++
-
-	var haveInto, haveStrict bool
-	var intoStartPos, intoEndPos int
-	var target []plpgsqltree.Variable
-	firstTok := l.tokens[startPos]
-	tok := firstTok
-	for pos := startPos; pos < endPos; pos++ {
-		prevTok := tok
-		tok = l.tokens[pos]
-		if tok.id == INTO {
-			if prevTok.id == INSERT || prevTok.id == UPSERT ||
-				prevTok.id == MERGE || firstTok.id == IMPORT {
-				// INSERT INTO, UPSERT INTO, MERGE INTO, and IMPORT ... INTO are not
-				// INTO-targets.
-				continue
-			}
-			if haveInto {
-				return nil, errors.New("INTO specified more than once")
-			}
-			haveInto = true
-			intoStartPos = pos
-			pos++
-			if pos+1 < endPos && l.tokens[pos].id == STRICT {
-				haveStrict = true
-				pos++
-			}
-			// Read in one or more comma-separated variables as the INTO target.
-			for ; pos < endPos; pos += 2 {
-				tok = l.tokens[pos]
-				if tok.id != IDENT {
-					return nil, errors.Newf("\"%s\" is not a scalar variable", tok.str)
-				}
-				variable := plpgsqltree.Variable(strings.TrimSpace(l.getStr(pos, pos+1)))
-				target = append(target, variable)
-				if pos+1 == endPos || l.tokens[pos+1].id != ',' {
-					// This is the end of the target list.
-					break
-				}
-			}
-			intoEndPos = pos + 1
-		}
-	}
-
-	var sql string
-	if haveInto {
-		sql = l.getStr(startPos, intoStartPos) + l.getStr(intoEndPos, endPos)
-	} else {
-		sql = l.getStr(startPos, endPos)
-	}
-	sqlStmt, err := parser.ParseOne(sql)
-	if err != nil {
-		return nil, err
-	}
-
-	// Note: PG disallows directly writing SQL statements that return rows, like
-	// a SELECT or a mutation with RETURNING. It is difficult to determine this
-	// for all possible statements, and execution is able to handle it, so we
-	// allow SQL statements that return rows.
-	if target != nil && sqlStmt.AST.StatementReturnType() != tree.Rows {
-		return nil, pgerror.New(pgcode.Syntax, "INTO used with a command that cannot return data")
-	}
-	return &plpgsqltree.Execute{
-		SqlStmt: sqlStmt.AST,
-		Strict:  haveStrict,
-		Target:  target,
-	}, nil
-}
-
-func (l *lexer) MakeDynamicExecuteStmt() (*plpgsqltree.DynamicExecute, error) {
-	cmdStr, _, err := l.ReadSqlStatement(INTO, USING, ';')
-	if err != nil {
-		return nil, err
-	}
-	ret := &plpgsqltree.DynamicExecute{
-		Query: cmdStr,
-	}
-
-	var lval plpgsqlSymType
-	l.Lex(&lval)
-	for {
-		if lval.id == INTO {
-			if ret.Into {
-				return nil, errors.New("multiple INTO keywords")
-			}
-			ret.Into = true
-			nextTok := l.Peek()
-			if nextTok.id == int32(STRICT) {
-				l.Lex(&lval)
-				ret.Strict = true
-			}
-			// TODO we need to read each "INTO" variable name instead of just a
-			// string.
-			_, _, err = l.ReadSqlExpr(USING, ';')
-			if err != nil {
-				return nil, err
-			}
-			l.Lex(&lval)
-		} else if lval.id == USING {
-			if ret.Params != nil {
-				return nil, errors.New("multiple USING keywords")
-			}
-			ret.Params = make([]plpgsqltree.Expr, 0)
-			for {
-				_, _, err = l.ReadSqlExpr(',', ';', INTO)
-				if err != nil {
-					return nil, err
-				}
-				ret.Params = append(ret.Params, nil)
-				l.Lex(&lval)
-				if lval.id == ';' {
-					break
-				}
-			}
-		} else if lval.id == ';' {
-			break
-		} else {
-			return nil, errors.Newf("unexpected token: %s", lval.id)
-		}
-	}
-
-	return ret, nil
-}
-
-func (l *lexer) readSQLConstruct(
-	isExpr bool, terminator1 int, terminators ...int,
-) (startPos, endPos, terminatorMet int, err error) {
-	if l.parser.Lookahead() != -1 {
-		// Push back the lookahead token so that it can be included.
-		l.PushBack(1)
-	}
-	parenLevel := 0
-	startPos = l.lastPos + 1
-	for l.lastPos < len(l.tokens) {
-		tok := l.Peek()
-		if int(tok.id) == terminator1 && parenLevel == 0 {
-			terminatorMet = terminator1
-			break
-		}
-		for _, term := range terminators {
-			if int(tok.id) == term && parenLevel == 0 {
-				terminatorMet = term
-			}
-		}
-		if terminatorMet != 0 {
-			break
-		}
-		if tok.id == '(' || tok.id == '[' {
-			parenLevel++
-		} else if tok.id == ')' || tok.id == ']' {
-			parenLevel--
-			if parenLevel < 0 {
-				return 0, 0, 0, errors.New("mismatched parentheses")
-			}
-		}
-		l.lastPos++
-	}
-	if parenLevel != 0 {
-		return 0, 0, 0, errors.New("mismatched parentheses")
-	}
-	endPos = l.lastPos + 1
-	if endPos > len(l.tokens) {
-		endPos = len(l.tokens)
-	}
-	if endPos <= startPos {
-		if isExpr {
-			return 0, 0, 0, errors.New("missing expression")
-		} else {
-			return 0, 0, 0, errors.New("missing SQL statement")
-		}
-	}
-	return startPos, endPos, terminatorMet, nil
-}
-
-func (l *lexer) MakeFetchOrMoveStmt(isMove bool) (plpgsqltree.Statement, error) {
-	if l.parser.Lookahead() != -1 {
-		// Push back the lookahead token so that it can be included.
-		l.PushBack(1)
-	}
-	prefix := "FETCH "
-	if isMove {
-		prefix = "MOVE "
-	}
-	sqlStr, terminator, err := l.ReadSqlStatement(INTO, ';')
-	if err != nil {
-		return nil, err
-	}
-	sqlStr = prefix + sqlStr
-	sqlStmt, err := parser.ParseOne(sqlStr)
-	if err != nil {
-		return nil, err
-	}
-	var cursor tree.CursorStmt
-	switch t := sqlStmt.AST.(type) {
-	case *tree.FetchCursor:
-		cursor = t.CursorStmt
-	case *tree.MoveCursor:
-		cursor = t.CursorStmt
-	default:
-		return nil, errors.Newf("invalid FETCH or MOVE syntax")
-	}
-	var target []plpgsqltree.Variable
-	if !isMove {
-		if terminator != INTO {
-			return nil, errors.Newf("invalid syntax for FETCH")
-		}
-		// Read past the INTO.
-		l.lastPos++
-		startPos, endPos, _, err := l.readSQLConstruct(true /* isExpr */, ';')
-		if err != nil {
-			return nil, err
-		}
-		for pos := startPos; pos < endPos; pos += 2 {
-			tok := l.tokens[pos]
-			if tok.id != IDENT {
-				return nil, errors.Newf("\"%s\" is not a scalar variable", tok.str)
-			}
-			if pos+1 != endPos && l.tokens[pos+1].id != ',' {
-				return nil, errors.Newf("expected INTO target to be a comma-separated list")
-			}
-			variable := plpgsqltree.Variable(strings.TrimSpace(l.getStr(pos, pos+1)))
-			target = append(target, variable)
-		}
-		if len(target) == 0 {
-			return nil, errors.Newf("expected INTO target")
-		}
-	}
-	// Move past the semicolon.
-	l.lastPos++
-	return &plpgsqltree.Fetch{
-		Cursor: cursor,
-		Target: target,
-		IsMove: isMove,
-	}, nil
-}
-
-func (l *lexer) ReadSqlExpr(
-	terminator1 int, terminators ...int,
-) (sqlStr string, terminatorMet int, err error) {
-	var startPos, endPos int
-	startPos, endPos, terminatorMet, err = l.readSQLConstruct(
-		true /* isExpr */, terminator1, terminators...,
-	)
-	return l.getStr(startPos, endPos), terminatorMet, err
-}
-
-func (l *lexer) ReadSqlStatement(
-	terminator1 int, terminators ...int,
-) (sqlStr string, terminatorMet int, err error) {
-	var startPos, endPos int
-	startPos, endPos, terminatorMet, err = l.readSQLConstruct(
-		false /* isExpr */, terminator1, terminators...,
-	)
-	return l.getStr(startPos, endPos), terminatorMet, err
-}
-
-func (l *lexer) getStr(startPos, endPos int) string {
-	if endPos <= startPos {
-		return ""
-	}
-	end := len(l.in)
-	if endPos < len(l.tokens) {
-		end = int(l.tokens[endPos].Pos())
-	}
-	start := int(l.tokens[startPos].Pos())
-	return l.in[start:end]
-}
-
-// Peek peeks
-func (l *lexer) Peek() plpgsqlSymType {
-	if l.lastPos+1 < len(l.tokens) {
-		return l.tokens[l.lastPos+1]
-	}
-	return plpgsqlSymType{}
-}
-
-// PushBack rewinds the lexer by n tokens.
-func (l *lexer) PushBack(n int) {
-	if n < 0 {
-		panic(errors.AssertionFailedf("negative n provided to PushBack"))
-	}
-	l.lastPos -= n
-	if l.lastPos < -1 {
-		// Return to the initialized state.
-		l.lastPos = -1
-	}
-	if n >= 1 {
-		// Invalidate the parser lookahead token.
-		l.parser.(*plpgsqlParserImpl).char = -1
-	}
-}
-
-func (l *lexer) lastToken() plpgsqlSymType {
-	if l.lastPos < 0 {
-		return plpgsqlSymType{}
-	}
-
-	if l.lastPos >= len(l.tokens) {
-		return plpgsqlSymType{
-			id:  0,
-			pos: int32(len(l.in)),
-			str: "EOF",
-		}
-	}
-	return l.tokens[l.lastPos]
-}
-
-// SetStmt is called from the parser when the statement is constructed.
-func (l *lexer) SetStmt(stmt plpgsqltree.Statement) {
-	l.stmt = stmt.(*plpgsqltree.Block)
-}
-
-// setErr is called from parsing action rules to register an error observed
-// while running the action. That error becomes the actual "cause" of the
-// syntax error.
-func (l *lexer) setErr(err error) {
-	err = pgerror.WithCandidateCode(err, pgcode.Syntax)
-	l.lastError = err
-	lastTok := l.lastToken()
-	l.lastError = parser.PopulateErrorDetails(lastTok.id, lastTok.str, lastTok.pos, l.lastError, l.in)
-}
-
-func (l *lexer) Error(e string) {
-	e = strings.TrimPrefix(e, "syntax error: ") // we'll add it again below.
-	err := pgerror.WithCandidateCode(errors.Newf("%s", e), pgcode.Syntax)
-	lastTok := l.lastToken()
-	l.lastError = parser.PopulateErrorDetails(lastTok.id, lastTok.str, lastTok.pos, err, l.in)
-}
-
-// Unimplemented wraps Error, setting lastUnimplementedError.
-func (l *lexer) Unimplemented(feature string) {
-	l.lastError = unimp.New(feature, "this syntax")
-	lastTok := l.lastToken()
-	l.lastError = parser.PopulateErrorDetails(lastTok.id, lastTok.str, lastTok.pos, l.lastError, l.in)
-	l.lastError = &tree.UnsupportedError{
-		Err:         l.lastError,
-		FeatureName: feature,
-	}
-}
-
-func (l *lexer) GetTypeFromValidSQLSyntax(sqlStr string) (tree.ResolvableTypeReference, error) {
-	return parser.GetTypeFromValidSQLSyntax(sqlStr)
-}
-
-func (l *lexer) ParseExpr(sqlStr string) (plpgsqltree.Expr, error) {
-	// Use ParseExprs instead of ParseExpr in order to correctly handle the case
-	// when multiple expressions are incorrectly passed.
-	exprs, err := parser.ParseExprs([]string{sqlStr})
-	if err != nil {
-		return nil, err
-	}
-	if len(exprs) != 1 {
-		return nil, pgerror.Newf(pgcode.Syntax, "query returned %d columns", len(exprs))
-	}
-	return exprs[0], nil
-}
-
-func checkLoopLabels(start, end string) error {
-	if start == "" && end != "" {
-		return errors.Newf("end label \"%s\" specified for unlabeled block", end)
-	}
-	if end != "" && start != end {
-		return errors.Newf("end label \"%s\" differs from block's label \"%s\"", end, start)
-	}
-	return nil
-}
diff --git a/pkg/sql/plpgsql/parser/parse.go b/pkg/sql/plpgsql/parser/parse.go
deleted file mode 100644
index 520830a..0000000
--- a/pkg/sql/plpgsql/parser/parse.go
+++ /dev/null
@@ -1,136 +0,0 @@
-// Copyright 2023 The Cockroach Authors.
-//
-// Use of this software is governed by the Business Source License
-// included in the file licenses/BSL.txt.
-//
-// As of the Change Date specified in that file, in accordance with
-// the Business Source License, use of this software will be governed
-// by the Apache License, Version 2.0, included in the file
-// licenses/APL.txt.
-
-// Package parser exposes a parser for plpgsql.
-package parser
-
-import (
-	"go/constant"
-
-	"github.com/cockroachdb/cockroachdb-parser/pkg/sql/parser/statements"
-	"github.com/cockroachdb/cockroachdb-parser/pkg/sql/scanner"
-	"github.com/cockroachdb/cockroachdb-parser/pkg/sql/sem/tree"
-	"github.com/cockroachdb/cockroachdb-parser/pkg/sql/types"
-	"github.com/cockroachdb/errors"
-)
-
-func init() {
-	scanner.NewNumValFn = func(a constant.Value, s string, b bool) interface{} { return tree.NewNumVal(a, s, b) }
-	scanner.NewPlaceholderFn = func(s string) (interface{}, error) { return tree.NewPlaceholder(s) }
-}
-
-// Parser wraps a scanner, parser and other utilities present in the parser
-// package.
-type Parser struct {
-	scanner    scanner.PLpgSQLScanner
-	lexer      lexer
-	parserImpl plpgsqlParserImpl
-	tokBuf     [8]plpgsqlSymType
-}
-
-// INT8 is the historical interpretation of INT. This should be left
-// alone in the future, since there are many sql fragments stored
-// in various descriptors. Any user input that was created after
-// INT := INT4 will simply use INT4 in any resulting code.
-var defaultNakedIntType = types.Int
-
-// Parse parses the sql and returns a list of statements.
-func (p *Parser) Parse(sql string) (statements.PLpgStatement, error) {
-	return p.parseWithDepth(1, sql, defaultNakedIntType)
-}
-
-func (p *Parser) scanFnBlock() (sql string, tokens []plpgsqlSymType, done bool) {
-	var lval plpgsqlSymType
-	tokens = p.tokBuf[:0]
-
-	// Scan the first token.
-	p.scanner.Scan(&lval)
-	if lval.id == 0 {
-		return "", nil, true
-	}
-
-	startPos := lval.pos
-	// We make the resulting token positions match the returned string.
-	lval.pos = 0
-	tokens = append(tokens, lval)
-	for {
-		if lval.id == ERROR {
-			return p.scanner.In()[startPos:], tokens, true
-		}
-		// Reset the plpgsqlSymType struct before scanning.
-		lval = plpgsqlSymType{}
-		posBeforeScan := p.scanner.Pos()
-		p.scanner.Scan(&lval)
-		if lval.id == 0 {
-			return p.scanner.In()[startPos:posBeforeScan], tokens, (lval.id == 0)
-		}
-		lval.pos -= startPos
-		tokens = append(tokens, lval)
-	}
-}
-
-func (p *Parser) parseWithDepth(
-	depth int, plpgsql string, nakedIntType *types.T,
-) (statements.PLpgStatement, error) {
-	p.scanner.Init(plpgsql)
-	defer p.scanner.Cleanup()
-	sql, tokens, done := p.scanFnBlock()
-	stmt, err := p.parse(depth+1, sql, tokens, nakedIntType)
-	if err != nil {
-		return statements.PLpgStatement{}, err
-	}
-	if !done {
-		return statements.PLpgStatement{}, errors.AssertionFailedf("invalid plpgsql function: %s", plpgsql)
-	}
-	return stmt, nil
-}
-
-// parse parses a statement from the given scanned tokens.
-func (p *Parser) parse(
-	depth int, sql string, tokens []plpgsqlSymType, nakedIntType *types.T,
-) (statements.PLpgStatement, error) {
-	p.lexer.init(sql, tokens, nakedIntType, &p.parserImpl)
-	defer p.lexer.cleanup()
-	if p.parserImpl.Parse(&p.lexer) != 0 {
-		if p.lexer.lastError == nil {
-			// This should never happen -- there should be an error object
-			// every time Parse() returns nonzero. We're just playing safe
-			// here.
-			p.lexer.Error("syntax error")
-		}
-		err := p.lexer.lastError
-
-		// Compatibility with 19.1 telemetry: prefix the telemetry keys
-		// with the "syntax." prefix.
-		// TODO(knz): move the auto-prefixing of feature names to a
-		// higher level in the call stack.
-		tkeys := errors.GetTelemetryKeys(err)
-		if len(tkeys) > 0 {
-			for i := range tkeys {
-				tkeys[i] = "syntax." + tkeys[i]
-			}
-			err = errors.WithTelemetry(err, tkeys...)
-		}
-
-		return statements.PLpgStatement{}, err
-	}
-	return statements.PLpgStatement{
-		AST:             p.lexer.stmt,
-		SQL:             sql,
-		NumPlaceholders: p.lexer.numPlaceholders,
-		NumAnnotations:  p.lexer.numAnnotations,
-	}, nil
-}
-
-// Parse parses a sql statement string and returns a list of Statements.
-func Parse(sql string) (statements.PLpgStatement, error) {
-	var p Parser
-	return p.parseWithDepth(1, sql, defaultNakedIntType)
-}
diff --git a/pkg/sql/plpgsql/parser/plpgsql.y b/pkg/sql/plpgsql/parser/plpgsql.y
deleted file mode 100644
index 8ee4069..0000000
--- a/pkg/sql/plpgsql/parser/plpgsql.y
+++ /dev/null
@@ -1,1647 +0,0 @@
-%{
-package parser
-
-import (
-  "github.com/cockroachdb/cockroach/pkg/sql/parser"
-  "github.com/cockroachdb/cockroach/pkg/sql/scanner"
-  "github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
-  "github.com/cockroachdb/cockroach/pkg/sql/sem/plpgsqltree"
-  "github.com/cockroachdb/errors"
-  "github.com/cockroachdb/redact"
-)
-%}
-
-%{
-func setErr(plpgsqllex plpgsqlLexer, err error) int {
-    plpgsqllex.(*lexer).setErr(err)
-    return 1
-}
-
-func unimplemented(plpgsqllex plpgsqlLexer, feature string) int {
-    plpgsqllex.(*lexer).Unimplemented(feature)
-    return 1
-}
-
-//functions to cast plpgsqlSymType/sqlSymUnion to other types.
-var _ scanner.ScanSymType = &plpgsqlSymType{}
-
-func (s *plpgsqlSymType) ID() int32 {
-  return s.id
-}
-
-func (s *plpgsqlSymType) SetID(id int32) {
-  s.id = id
-}
-
-func (s *plpgsqlSymType) Pos() int32 {
-  return s.pos
-}
-
-func (s *plpgsqlSymType) SetPos(pos int32) {
-  s.pos = pos
-}
-
-func (s *plpgsqlSymType) Str() string {
-  return s.str
-}
-
-func (s *plpgsqlSymType) SetStr(str string) {
-  s.str = str
-}
-
-func (s *plpgsqlSymType) UnionVal() interface{} {
-  return s.union.val
-}
-
-func (s *plpgsqlSymType) SetUnionVal(val interface{}) {
-  s.union.val = val
-}
-
-func (s *plpgsqlSymType) plpgsqlScanSymType() {}
-
-type plpgsqlSymUnion struct {
-    val interface{}
-}
-
-func (u *plpgsqlSymUnion) block() *plpgsqltree.Block {
-    return u.val.(*plpgsqltree.Block)
-}
-
-func (u *plpgsqlSymUnion) caseWhen() *plpgsqltree.CaseWhen {
-    return u.val.(*plpgsqltree.CaseWhen)
-}
-
-func (u *plpgsqlSymUnion) caseWhens() []*plpgsqltree.CaseWhen {
-    return u.val.([]*plpgsqltree.CaseWhen)
-}
-
-func (u *plpgsqlSymUnion) statement() plpgsqltree.Statement {
-    return u.val.(plpgsqltree.Statement)
-}
-
-func (u *plpgsqlSymUnion) statements() []plpgsqltree.Statement {
-    return u.val.([]plpgsqltree.Statement)
-}
-
-func (u *plpgsqlSymUnion) int32() int32 {
-    return u.val.(int32)
-}
-
-func (u *plpgsqlSymUnion) uint32() uint32 {
-    return u.val.(uint32)
-}
-
-func (u *plpgsqlSymUnion) bool() bool {
-    return u.val.(bool)
-}
-
-func (u *plpgsqlSymUnion) numVal() *tree.NumVal {
-    return u.val.(*tree.NumVal)
-}
-
-func (u *plpgsqlSymUnion) typ() tree.ResolvableTypeReference {
-    return u.val.(tree.ResolvableTypeReference)
-}
-
-func (u *plpgsqlSymUnion) getDiagnosticsKind() plpgsqltree.GetDiagnosticsKind {
-    return u.val.(plpgsqltree.GetDiagnosticsKind)
-}
-
-func (u *plpgsqlSymUnion) getDiagnosticsItem() *plpgsqltree.GetDiagnosticsItem {
-    return u.val.(*plpgsqltree.GetDiagnosticsItem)
-}
-
-func (u *plpgsqlSymUnion) getDiagnosticsItemList() plpgsqltree.GetDiagnosticsItemList {
-    return u.val.(plpgsqltree.GetDiagnosticsItemList)
-}
-
-func (u *plpgsqlSymUnion) elseIf() []plpgsqltree.ElseIf {
-    return u.val.([]plpgsqltree.ElseIf)
-}
-
-func (u *plpgsqlSymUnion) open() *plpgsqltree.Open {
-    return u.val.(*plpgsqltree.Open)
-}
-
-func (u *plpgsqlSymUnion) expr() plpgsqltree.Expr {
-    if u.val == nil {
-        return nil
-    }
-    return u.val.(plpgsqltree.Expr)
-}
-
-func (u *plpgsqlSymUnion) exprs() []plpgsqltree.Expr {
-    return u.val.([]plpgsqltree.Expr)
-}
-
-func (u *plpgsqlSymUnion) raiseOption() *plpgsqltree.RaiseOption {
-    return u.val.(*plpgsqltree.RaiseOption)
-}
-
-func (u *plpgsqlSymUnion) raiseOptions() []plpgsqltree.RaiseOption {
-    return u.val.([]plpgsqltree.RaiseOption)
-}
-
-
-func (u *plpgsqlSymUnion) exception() *plpgsqltree.Exception {
-    return u.val.(*plpgsqltree.Exception)
-}
-
-func (u *plpgsqlSymUnion) exceptions() []plpgsqltree.Exception {
-    return u.val.([]plpgsqltree.Exception)
-}
-
-func (u *plpgsqlSymUnion) condition() *plpgsqltree.Condition {
-    return u.val.(*plpgsqltree.Condition)
-}
-
-func (u *plpgsqlSymUnion) conditions() []plpgsqltree.Condition {
-    return u.val.([]plpgsqltree.Condition)
-}
-
-func (u *plpgsqlSymUnion) cursorScrollOption() tree.CursorScrollOption {
-    return u.val.(tree.CursorScrollOption)
-}
-
-func (u *plpgsqlSymUnion) sqlStatement() tree.Statement {
-    return u.val.(tree.Statement)
-}
-
-%}
-/*
- * Basic non-keyword token types.  These are hard-wired into the core lexer.
- * They must be listed first so that their numeric codes do not depend on
- * the set of keywords.  Keep this list in sync with backend/parser/gram.y!
- *
- * Some of these are not directly referenced in this file, but they must be
- * here anyway.
- */
-%token <str> IDENT UIDENT FCONST SCONST USCONST BCONST XCONST Op
-%token <*tree.NumVal>	ICONST PARAM
-%token <str> TYPECAST DOT_DOT COLON_EQUALS EQUALS_GREATER
-%token <str> LESS_EQUALS GREATER_EQUALS NOT_EQUALS
-
-/*
- * Other tokens recognized by plpgsql's lexer interface layer (pl_scanner.c).
- */
-%token <str> LESS_LESS GREATER_GREATER
-
-/*
- * Keyword tokens.  Some of these are reserved and some are not;
- * see pl_scanner.c for info.  Be sure unreserved keywords are listed
- * in the "unreserved_keyword" production below.
- */
-%token <str>  ABSOLUTE
-%token <str>  ALIAS
-%token <str>  ALL
-%token <str>  AND
-%token <str>  ARRAY
-%token <str>  ASSERT
-%token <str>  BACKWARD
-%token <str>  BEGIN
-%token <str>  BY
-%token <str>  CALL
-%token <str>  CASE
-%token <str>  CHAIN
-%token <str>  CLOSE
-%token <str>  COLLATE
-%token <str>  COLUMN
-%token <str>  COLUMN_NAME
-%token <str>  COMMIT
-%token <str>  CONSTANT
-%token <str>  CONSTRAINT
-%token <str>  CONSTRAINT_NAME
-%token <str>  CONTINUE
-%token <str>  CURRENT
-%token <str>  CURSOR
-%token <str>  DATATYPE
-%token <str>  DEBUG
-%token <str>  DECLARE
-%token <str>  DEFAULT
-%token <str>  DETAIL
-%token <str>  DIAGNOSTICS
-%token <str>  DO
-%token <str>  DUMP
-%token <str>  ELSE
-%token <str>  ELSIF
-%token <str>  END
-%token <str>  END_CASE
-%token <str>  END_IF
-%token <str>  ERRCODE
-%token <str>  ERROR
-%token <str>  EXCEPTION
-%token <str>  EXECUTE
-%token <str>  EXIT
-%token <str>  FETCH
-%token <str>  FIRST
-%token <str>  FOR
-%token <str>  FOREACH
-%token <str>  FORWARD
-%token <str>  FROM
-%token <str>  GET
-%token <str>  HINT
-%token <str>  IF
-%token <str>  IMPORT
-%token <str>  IN
-%token <str>  INFO
-%token <str>  INSERT
-%token <str>  INTO
-%token <str>  IS
-%token <str>  LAST
-%token <str>  LOG
-%token <str>  LOOP
-%token <str>  MERGE
-%token <str>  MESSAGE
-%token <str>  MESSAGE_TEXT
-%token <str>  MOVE
-%token <str>  NEXT
-%token <str>  NO
-%token <str>  NO_SCROLL
-%token <str>  NOT
-%token <str>  NOTICE
-%token <str>  NULL
-%token <str>  OPEN
-%token <str>  OPTION
-%token <str>  OR
-%token <str>  PERFORM
-%token <str>  PG_CONTEXT
-%token <str>  PG_DATATYPE_NAME
-%token <str>  PG_EXCEPTION_CONTEXT
-%token <str>  PG_EXCEPTION_DETAIL
-%token <str>  PG_EXCEPTION_HINT
-%token <str>  PRINT_STRICT_PARAMS
-%token <str>  PRIOR
-%token <str>  QUERY
-%token <str>  RAISE
-%token <str>  RELATIVE
-%token <str>  RETURN
-%token <str>  RETURN_NEXT
-%token <str>  RETURN_QUERY
-%token <str>  RETURNED_SQLSTATE
-%token <str>  REVERSE
-%token <str>  ROLLBACK
-%token <str>  ROW_COUNT
-%token <str>  ROWTYPE
-%token <str>  SCHEMA
-%token <str>  SCHEMA_NAME
-%token <str>  SCROLL
-%token <str>  SLICE
-%token <str>  SQLSTATE
-%token <str>  STACKED
-%token <str>  STRICT
-%token <str>  TABLE
-%token <str>  TABLE_NAME
-%token <str>  THEN
-%token <str>  TO
-%token <str>  TYPE
-%token <str>  UPSERT
-%token <str>  USE_COLUMN
-%token <str>  USE_VARIABLE
-%token <str>  USING
-%token <str>  VARIABLE_CONFLICT
-%token <str>  WARNING
-%token <str>  WHEN
-%token <str>  WHILE
-
-
-%union {
-  id    int32
-  pos   int32
-  str   string
-  union plpgsqlSymUnion
-}
-
-%type <str> decl_varname decl_defkey
-%type <bool>	decl_const decl_notnull
-%type <plpgsqltree.Expr>	decl_defval decl_cursor_query
-%type <tree.ResolvableTypeReference>	decl_datatype
-%type <str>		decl_collate
-
-%type <str>	expr_until_semi expr_until_paren stmt_until_semi
-%type <str>	expr_until_then expr_until_loop opt_expr_until_when
-%type <plpgsqltree.Expr>	opt_exitcond
-
-%type <forvariable>	for_variable
-%type <plpgsqltree.Expr>	return_variable
-%type <*tree.NumVal>	foreach_slice
-%type <plpgsqltree.Statement>	for_control
-
-%type <str> any_identifier opt_block_label opt_loop_label opt_label query_options
-%type <str> opt_error_level option_type
-
-%type <[]plpgsqltree.Statement> proc_sect
-%type <[]plpgsqltree.ElseIf> stmt_elsifs
-%type <[]plpgsqltree.Statement> stmt_else loop_body // TODO is this a list of statement?
-%type <plpgsqltree.Statement>  pl_block
-%type <plpgsqltree.Statement>	proc_stmt
-%type <plpgsqltree.Statement>	stmt_assign stmt_if stmt_loop stmt_while stmt_exit stmt_continue
-%type <plpgsqltree.Statement>	stmt_return stmt_raise stmt_assert stmt_execsql
-%type <plpgsqltree.Statement>	stmt_dynexecute stmt_for stmt_perform stmt_call stmt_getdiag
-%type <plpgsqltree.Statement>	stmt_open stmt_fetch stmt_move stmt_close stmt_null
-%type <plpgsqltree.Statement>	stmt_commit stmt_rollback
-%type <plpgsqltree.Statement>	stmt_case stmt_foreach_a
-
-%type <plpgsqltree.Statement> decl_stmt decl_statement
-%type <[]plpgsqltree.Statement> decl_sect opt_decl_stmts decl_stmts
-
-%type <[]plpgsqltree.Exception> exception_sect proc_exceptions
-%type <*plpgsqltree.Exception>	proc_exception
-%type <[]plpgsqltree.Condition> proc_conditions
-%type <*plpgsqltree.Condition> proc_condition
-
-%type <*plpgsqltree.CaseWhen>	case_when
-%type <[]*plpgsqltree.CaseWhen>	case_when_list
-%type <[]plpgsqltree.Statement> opt_case_else
-
-%type <bool>	getdiag_area_opt
-%type <plpgsqltree.GetDiagnosticsItemList>	getdiag_list // TODO don't know what this is
-%type <*plpgsqltree.GetDiagnosticsItem> getdiag_list_item // TODO don't know what this is
-%type <int32> getdiag_item
-
-%type <*plpgsqltree.RaiseOption> option_expr
-%type <[]plpgsqltree.RaiseOption> option_exprs opt_option_exprs
-%type <plpgsqltree.Expr> format_expr
-%type <[]plpgsqltree.Expr> opt_format_exprs format_exprs
-
-%type <tree.CursorScrollOption>	opt_scrollable
-
-%type <*tree.NumVal>	opt_transaction_chain
-
-%type <str>	unreserved_keyword
-%%
-
-pl_function:
-  pl_block opt_semi
-  {
-    plpgsqllex.(*lexer).SetStmt($1.statement())
-  }
-
-opt_semi:
-| ';'
-;
-
-pl_block: opt_block_label decl_sect BEGIN proc_sect exception_sect END opt_label
-  {
-    $$.val = &plpgsqltree.Block{
-      Label: $1,
-      Decls: $2.statements(),
-      Body: $4.statements(),
-      Exceptions: $5.exceptions(),
-    }
-  }
-;
-
-decl_sect: DECLARE opt_decl_stmts
-  {
-    $$.val = $2.statements()
-  }
-| /* EMPTY */
-  {
-    // Use a nil slice to indicate DECLARE was not used.
-    $$.val = []plpgsqltree.Statement(nil)
-  }
-;
-
-opt_decl_stmts: decl_stmts
-  {
-    $$.val = $1.statements()
-  }
-| /* EMPTY */
-  {
-    $$.val = []plpgsqltree.Statement{}
-  }
-;
-
-decl_stmts: decl_stmts decl_stmt
-  {
-    decs := $1.statements()
-    dec := $2.statement()
-    $$.val = append(decs, dec)
-  }
-| decl_stmt
-  {
-    dec := $1.statement()
-    $$.val = []plpgsqltree.Statement{dec}
-	}
-;
-
-decl_stmt	: decl_statement
-  {
-    $$.val = $1.statement()
-  }
-| DECLARE
-  {
-    // This is to allow useless extra "DECLARE" keywords in the declare section.
-    $$.val = (plpgsqltree.Statement)(nil)
-  }
-// TODO(chengxiong): turn this block on and throw useful error if user
-// tries to put the block label just before BEGIN instead of before
-// DECLARE.
-//| LESS_LESS any_identifier GREATER_GREATER
-//  {
-//  }
-;
-
-decl_statement: decl_varname decl_const decl_datatype decl_collate decl_notnull decl_defval
-  {
-    $$.val = &plpgsqltree.Declaration{
-      Var: plpgsqltree.Variable($1),
-      Constant: $2.bool(),
-      Typ: $3.typ(),
-      Collate: $4,
-      NotNull: $5.bool(),
-      Expr: $6.expr(),
-    }
-  }
-| decl_varname ALIAS FOR decl_aliasitem ';'
-  {
-    return unimplemented(plpgsqllex, "alias for")
-  }
-| decl_varname opt_scrollable CURSOR decl_cursor_args decl_is_for decl_cursor_query
-  {
-    $$.val = &plpgsqltree.CursorDeclaration{
-      Name: plpgsqltree.Variable($1),
-      Scroll: $2.cursorScrollOption(),
-      Query: $6.sqlStatement(),
-    }
-  }
-;
-
-opt_scrollable:
-  {
-    $$.val = tree.UnspecifiedScroll
-  }
-| NO_SCROLL SCROLL
-  {
-    $$.val = tree.NoScroll
-  }
-| SCROLL
-  {
-    $$.val = tree.Scroll
-  }
-;
-
-decl_cursor_query: stmt_until_semi ';'
-  {
-    stmts, err := parser.Parse($1)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    if len(stmts) != 1 {
-      return setErr(plpgsqllex, errors.New("expected exactly one SQL statement for cursor"))
-    }
-    $$.val = stmts[0].AST
-  }
-;
-
-decl_cursor_args: '('
-  {
-    return unimplemented(plpgsqllex, "cursor arguments")
-  }
-| /* EMPTY */
-  {
-  }
-;
-
-decl_cursor_arglist: decl_cursor_arg
-  {
-  }
-| decl_cursor_arglist ',' decl_cursor_arg
-  {
-  }
-;
-
-decl_cursor_arg: decl_varname decl_datatype
-  {
-  }
-;
-
-decl_is_for:
-  IS   /* Oracle */
-| FOR  /* SQL standard */
-
-decl_aliasitem: IDENT
-  {
-  }
-| unreserved_keyword
-  {
-  }
-;
-
-decl_varname: IDENT
-| unreserved_keyword
-;
-
-decl_const:
-  {
-    $$.val = false
-  }
-| CONSTANT
-  {
-    $$.val = true
-  }
-;
-
-decl_datatype:
-  {
-    // Read until reaching one of the tokens that can follow a declaration
-    // data type.
-    sqlStr, _, err := plpgsqllex.(*lexer).ReadSqlExpr(
-      ';', COLLATE, NOT, '=', COLON_EQUALS, DECLARE,
-    )
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    typ, err := plpgsqllex.(*lexer).GetTypeFromValidSQLSyntax(sqlStr)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = typ
-  }
-;
-
-decl_collate:
-  {
-    $$ = ""
-  }
-| COLLATE IDENT
-  {
-    $$ = $2
-  }
-| COLLATE unreserved_keyword
-  {
-    $$ = $2
-  }
-;
-
-decl_notnull:
-  {
-    $$.val = false
-  }
-| NOT NULL
-  {
-    $$.val = true
-  }
-;
-
-decl_defval: ';'
-  {
-    $$.val = (plpgsqltree.Expr)(nil)
-  }
-| decl_defkey ';'
-  {
-    expr, err := plpgsqllex.(*lexer).ParseExpr($1)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = expr
-  }
-;
-
-decl_defkey: assign_operator
-  {
-    sqlStr, _, err := plpgsqllex.(*lexer).ReadSqlExpr(';')
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$ = sqlStr
-  }
-| DEFAULT
-  {
-    sqlStr, _, err := plpgsqllex.(*lexer).ReadSqlExpr(';')
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$ = sqlStr
-  }
-;
-
-/*
- * Ada-based PL/SQL uses := for assignment and variable defaults, while
- * the SQL standard uses equals for these cases and for GET
- * DIAGNOSTICS, so we support both.  FOR and OPEN only support :=.
- */
-assign_operator: '='
-| COLON_EQUALS
-;
-
-proc_sect:
-  {
-    $$.val = []plpgsqltree.Statement{}
-  }
-| proc_sect proc_stmt
-  {
-    stmts := $1.statements()
-    stmts = append(stmts, $2.statement())
-    $$.val = stmts
-  }
-;
-
-proc_stmt:pl_block ';'
-  {
-    $$.val = $1.block()
-  }
-| stmt_assign
-  {
-    $$.val = $1.statement()
-  }
-| stmt_if
-  {
-    $$.val = $1.statement()
-  }
-| stmt_case
-  {
-    $$.val = $1.statement()
-  }
-| stmt_loop
-  {
-    $$.val = $1.statement()
-  }
-| stmt_while
-  { }
-| stmt_for
-  { }
-| stmt_foreach_a
-  { }
-| stmt_exit
-  {
-    $$.val = $1.statement()
-  }
-| stmt_continue
-  {
-    $$.val = $1.statement()
-  }
-| stmt_return
-  {
-    $$.val = $1.statement()
-  }
-| stmt_raise
-  {
-    $$.val = $1.statement()
-  }
-| stmt_assert
-  {
-    $$.val = $1.statement()
-  }
-| stmt_execsql
-  {
-    $$.val = $1.statement()
-  }
-| stmt_dynexecute
-  {
-    $$.val = $1.statement()
-  }
-| stmt_perform
-  { }
-| stmt_call
-  {
-    $$.val = $1.statement()
-  }
-| stmt_getdiag
-  { }
-| stmt_open
-  {
-    $$.val = $1.statement()
-  }
-| stmt_fetch
-  {
-    $$.val = $1.statement()
-  }
-| stmt_move
-  {
-    $$.val = $1.statement()
-  }
-| stmt_close
-  {
-    $$.val = $1.statement()
-  }
-| stmt_null
-  { }
-| stmt_commit
-  { }
-| stmt_rollback
-  { }
-;
-
-stmt_perform: PERFORM stmt_until_semi ';'
-  {
-    return unimplemented(plpgsqllex, "perform")
-  }
-;
-
-stmt_call: CALL call_cmd ';'
-  {
-    $$.val = &plpgsqltree.Call{IsCall: true}
-  }
-| DO call_cmd ';'
-  {
-    $$.val = &plpgsqltree.Call{IsCall: false}
-  }
-;
-
-call_cmd:
-  {
-    _, _, err := plpgsqllex.(*lexer).ReadSqlExpr(';')
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-  }
-;
-
-stmt_assign: IDENT assign_operator expr_until_semi ';'
-  {
-    expr, err := plpgsqllex.(*lexer).ParseExpr($3)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = &plpgsqltree.Assignment{
-      Var: plpgsqltree.Variable($1),
-      Value: expr,
-    }
-  }
-;
-
-stmt_getdiag: GET getdiag_area_opt DIAGNOSTICS getdiag_list ';'
-  {
-  $$.val = &plpgsqltree.GetDiagnostics{
-    IsStacked: $2.bool(),
-    DiagItems: $4.getDiagnosticsItemList(),
-  }
-  // TODO(jane): Check information items are valid for area option.
-  }
-;
-
-getdiag_area_opt:
-  {
-    $$.val = false
-  }
-| CURRENT
-  {
-    $$.val = false
-  }
-| STACKED
-  {
-    $$.val = true
-  }
-;
-
-getdiag_list: getdiag_list ',' getdiag_list_item
-  {
-    $$.val = append($1.getDiagnosticsItemList(), $3.getDiagnosticsItem())
-  }
-| getdiag_list_item
-  {
-    $$.val = plpgsqltree.GetDiagnosticsItemList{$1.getDiagnosticsItem()}
-  }
-;
-
-getdiag_list_item: IDENT assign_operator getdiag_item
-  {
-    $$.val = &plpgsqltree.GetDiagnosticsItem{
-      Kind : $3.getDiagnosticsKind(),
-      TargetName: $1,
-      // TODO(jane): set the target from $1.
-    }
-  }
-;
-
-getdiag_item: unreserved_keyword {
-  switch $1 {
-    case "row_count":
-      $$.val = plpgsqltree.GetDiagnosticsRowCount;
-    case "pg_context":
-      $$.val = plpgsqltree.GetDiagnosticsContext;
-    case "pg_exception_detail":
-      $$.val = plpgsqltree.GetDiagnosticsErrorDetail;
-    case "pg_exception_hint":
-      $$.val = plpgsqltree.GetDiagnosticsErrorHint;
-    case "pg_exception_context":
-      $$.val = plpgsqltree.GetDiagnosticsErrorContext;
-    case "column_name":
-      $$.val = plpgsqltree.GetDiagnosticsColumnName;
-    case "constraint_name":
-      $$.val = plpgsqltree.GetDiagnosticsConstraintName;
-    case "pg_datatype_name":
-      $$.val = plpgsqltree.GetDiagnosticsDatatypeName;
-    case "message_text":
-      $$.val = plpgsqltree.GetDiagnosticsMessageText;
-    case "table_name":
-      $$.val = plpgsqltree.GetDiagnosticsTableName;
-    case "schema_name":
-      $$.val = plpgsqltree.GetDiagnosticsSchemaName;
-    case "returned_sqlstate":
-      $$.val = plpgsqltree.GetDiagnosticsReturnedSQLState;
-    default:
-      // TODO(jane): Should this use an unimplemented error instead?
-      return setErr(plpgsqllex, errors.Newf("unrecognized GET DIAGNOSTICS item: %s", redact.Safe($1)))
-  }
-}
-;
-
-getdiag_target:
-// TODO(jane): remove ident.
-IDENT
-  {
-  }
-;
-
-stmt_if: IF expr_until_then THEN proc_sect stmt_elsifs stmt_else END_IF IF ';'
-  {
-    cond, err := plpgsqllex.(*lexer).ParseExpr($2)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = &plpgsqltree.If{
-      Condition: cond,
-      ThenBody: $4.statements(),
-      ElseIfList: $5.elseIf(),
-      ElseBody: $6.statements(),
-    }
-  }
-;
-
-stmt_elsifs:
-  {
-    $$.val = []plpgsqltree.ElseIf{};
-  }
-| stmt_elsifs ELSIF expr_until_then THEN proc_sect
-  {
-    cond, err := plpgsqllex.(*lexer).ParseExpr($3)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    newStmt := plpgsqltree.ElseIf{
-      Condition: cond,
-      Stmts: $5.statements(),
-    }
-    $$.val = append($1.elseIf() , newStmt)
-  }
-;
-
-stmt_else:
-  {
-    $$.val = []plpgsqltree.Statement{};
-  }
-| ELSE proc_sect
-  {
-    $$.val = $2.statements();
-  }
-;
-
-stmt_case: CASE opt_expr_until_when case_when_list opt_case_else END_CASE CASE ';'
-  {
-    expr := &plpgsqltree.Case {
-      TestExpr: $2,
-      CaseWhenList: $3.caseWhens(),
-    }
-    if $4.val != nil {
-       expr.HaveElse = true
-       expr.ElseStmts = $4.statements()
-    }
-    $$.val = expr
-  }
-;
-
-opt_expr_until_when:
-  {
-    if plpgsqllex.(*lexer).Peek().id != WHEN {
-      sqlStr, _, err := plpgsqllex.(*lexer).ReadSqlExpr(WHEN)
-      if err != nil {
-        return setErr(plpgsqllex, err)
-      }
-      $$ = sqlStr
-    } else {
-      $$ = ""
-    }
-  }
-;
-
-case_when_list: case_when_list case_when
-  {
-    stmts := $1.caseWhens()
-    stmts = append(stmts, $2.caseWhen())
-    $$.val = stmts
-  }
-| case_when
-  {
-    stmts := []*plpgsqltree.CaseWhen{}
-    stmts = append(stmts, $1.caseWhen())
-    $$.val = stmts
-  }
-;
-
-case_when: WHEN expr_until_then THEN proc_sect
-  {
-     expr := &plpgsqltree.CaseWhen{
-       Expr: $2,
-       Stmts: $4.statements(),
-     }
-     $$.val = expr
-  }
-;
-
-opt_case_else:
-  {
-    $$.val = nil
-  }
-| ELSE proc_sect
-  {
-    $$.val = $2.statements()
-  }
-;
-
-stmt_loop: opt_loop_label LOOP loop_body opt_label ';'
-  {
-    loopLabel, loopEndLabel := $1, $4
-    if err := checkLoopLabels(loopLabel, loopEndLabel); err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = &plpgsqltree.Loop{
-      Label: $1,
-      Body: $3.statements(),
-    }
-  }
-;
-
-stmt_while: opt_loop_label WHILE expr_until_loop LOOP loop_body opt_label ';'
-  {
-    loopLabel, loopEndLabel := $1, $6
-    if err := checkLoopLabels(loopLabel, loopEndLabel); err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    cond, err := plpgsqllex.(*lexer).ParseExpr($3)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = &plpgsqltree.While{
-      Label: $1,
-      Condition: cond,
-      Body: $5.statements(),
-    }
-  }
-;
-
-stmt_for: opt_loop_label FOR for_control loop_body
-  {
-    return unimplemented(plpgsqllex, "for loop")
-  }
-;
-
-for_control: for_variable IN
-  // TODO need to parse the sql expression here.
-  {
-    return unimplemented(plpgsqllex, "for loop")
-  }
-;
-
-/*
- * Processing the for_variable is tricky because we don't yet know if the
- * FOR is an integer FOR loop or a loop over query results.  In the former
- * case, the variable is just a name that we must instantiate as a loop
- * local variable, regardless of any other definition it might have.
- * Therefore, we always save the actual identifier into $$.name where it
- * can be used for that case.  We also save the outer-variable definition,
- * if any, because that's what we need for the loop-over-query case.  Note
- * that we must NOT apply check_assignable() or any other semantic check
- * until we know what's what.
- *
- * However, if we see a comma-separated list of names, we know that it
- * can't be an integer FOR loop and so it's OK to check the variables
- * immediately.  In particular, for T_WORD followed by comma, we should
- * complain that the name is not known rather than say it's a syntax error.
- * Note that the non-error result of this case sets *both* $$.scalar and
- * $$.row; see the for_control production.
- */
-for_variable: any_identifier
-  {
-    return unimplemented(plpgsqllex, "for loop")
-  }
-;
-
-stmt_foreach_a: opt_loop_label FOREACH for_variable foreach_slice IN ARRAY expr_until_loop loop_body
-  {
-    return unimplemented(plpgsqllex, "for each loop")
-  }
-;
-
-foreach_slice:
-  {
-  }
-| SLICE ICONST
-  {
-  }
-;
-
-stmt_exit: EXIT opt_label opt_exitcond
-  {
-    $$.val = &plpgsqltree.Exit{
-      Label: $2,
-      Condition: $3.expr(),
-    }
-  }
-;
-
-stmt_continue: CONTINUE opt_label opt_exitcond
-  {
-    $$.val = &plpgsqltree.Continue{
-      Label: $2,
-      Condition: $3.expr(),
-    }
-  }
-;
-
-  // TODO handle variable names
-  // 1. verify if the first token is a variable (this means that we need to track variable scope during parsing)
-  // 2. if yes, check next token is ';'
-  // 3. if no, expecting a sql expression "read_sql_expression"
-  //    we can just read until a ';', then do the sql expression validation during compile time.
-
-stmt_return: RETURN return_variable ';'
-  {
-    $$.val = &plpgsqltree.Return{
-      Expr: $2.expr(),
-    }
-  }
-| RETURN_NEXT NEXT
-  {
-    return unimplemented(plpgsqllex, "return next")
-  }
-| RETURN_QUERY QUERY
- {
-   return unimplemented (plpgsqllex, "return query")
- }
-;
-
-
-query_options:
-  {
-    _, terminator, err := plpgsqllex.(*lexer).ReadSqlExpr(EXECUTE, ';')
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    if terminator == EXECUTE {
-      return unimplemented (plpgsqllex, "return dynamic sql query")
-    }
-    _, _, err = plpgsqllex.(*lexer).ReadSqlExpr(';')
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-  }
-;
-
-
-return_variable: expr_until_semi
-  {
-    expr, err := plpgsqllex.(*lexer).ParseExpr($1)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = expr
-  }
-;
-
-stmt_raise:
-  RAISE ';'
-  {
-    return unimplemented(plpgsqllex, "empty RAISE statement")
-  }
-| RAISE opt_error_level SCONST opt_format_exprs opt_option_exprs ';'
-  {
-    $$.val = &plpgsqltree.Raise{
-      LogLevel: $2,
-      Message: $3,
-      Params: $4.exprs(),
-      Options: $5.raiseOptions(),
-    }
-  }
-| RAISE opt_error_level IDENT opt_option_exprs ';'
-  {
-    $$.val = &plpgsqltree.Raise{
-      LogLevel: $2,
-      CodeName: $3,
-      Options: $4.raiseOptions(),
-    }
-  }
-| RAISE opt_error_level SQLSTATE SCONST opt_option_exprs ';'
-  {
-    $$.val = &plpgsqltree.Raise{
-      LogLevel: $2,
-      Code: $4,
-      Options: $5.raiseOptions(),
-    }
-  }
-| RAISE opt_error_level USING option_exprs ';'
-  {
-    $$.val = &plpgsqltree.Raise{
-      LogLevel: $2,
-      Options: $4.raiseOptions(),
-    }
-  }
-;
-
-opt_error_level:
-  DEBUG
-| LOG
-| INFO
-| NOTICE
-| WARNING
-| EXCEPTION
-| /* EMPTY */
-  {
-    $$ = ""
-  }
-;
-
-opt_option_exprs:
-  USING option_exprs
-  {
-    $$.val = $2.raiseOptions()
-  }
-| /* EMPTY */
-  {
-    $$.val = []plpgsqltree.RaiseOption{}
-  }
-;
-
-option_exprs:
-  option_exprs ',' option_expr
-  {
-    option := $3.raiseOption()
-    $$.val = append($1.raiseOptions(), *option)
-  }
-| option_expr
-  {
-    option := $1.raiseOption()
-    $$.val = []plpgsqltree.RaiseOption{*option}
-  }
-;
-
-option_expr:
-  option_type assign_operator
-  {
-    // Read until reaching one of the tokens that can follow a raise option.
-    sqlStr, _, err := plpgsqllex.(*lexer).ReadSqlExpr(',', ';')
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    optionExpr, err := plpgsqllex.(*lexer).ParseExpr(sqlStr)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = &plpgsqltree.RaiseOption{
-      OptType: $1,
-      Expr: optionExpr,
-    }
-  }
-;
-
-option_type:
-  MESSAGE
-| DETAIL
-| HINT
-| ERRCODE
-| COLUMN
-| CONSTRAINT
-| DATATYPE
-| TABLE
-| SCHEMA
-;
-
-opt_format_exprs:
-  format_exprs
-  {
-    $$.val = $1.exprs()
-  }
- | /* EMPTY */
-  {
-    $$.val = []plpgsqltree.Expr{}
-  }
-;
-
-format_exprs:
-  format_expr
-  {
-    $$.val = []plpgsqltree.Expr{$1.expr()}
-  }
-| format_exprs format_expr
-  {
-    $$.val = append($1.exprs(), $2.expr())
-  }
-;
-
-format_expr: ','
-  {
-    // Read until reaching a token that can follow a raise format parameter.
-    sqlStr, _, err := plpgsqllex.(*lexer).ReadSqlExpr(',', ';', USING)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    param, err := plpgsqllex.(*lexer).ParseExpr(sqlStr)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = param
-  }
-;
-
-stmt_assert: ASSERT assert_cond ';'
-  {
-    $$.val = &plpgsqltree.Assert{}
-  }
-;
-
-assert_cond:
-  {
-    _, terminator, err := plpgsqllex.(*lexer).ReadSqlExpr(',', ';')
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    if terminator == ',' {
-      _, _, err = plpgsqllex.(*lexer).ReadSqlExpr(';')
-      if err != nil {
-        return setErr(plpgsqllex, err)
-      }
-    }
-  }
-;
-
-loop_body: proc_sect END LOOP
-  {
-    $$.val = $1.statements()
-  }
-;
-
-stmt_execsql: stmt_execsql_start
-  {
-    stmt, err := plpgsqllex.(*lexer).MakeExecSqlStmt()
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = stmt
-  }
-;
-
-stmt_execsql_start:
-  IMPORT
-| INSERT
-| UPSERT
-| MERGE
-| IDENT
-;
-
-stmt_dynexecute: EXECUTE
-  {
-    stmt, err := plpgsqllex.(*lexer).MakeDynamicExecuteStmt()
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = stmt
-  }
-;
-
-stmt_open: OPEN IDENT ';'
-  {
-    $$.val = &plpgsqltree.Open{CurVar: plpgsqltree.Variable($2)}
-  }
-| OPEN IDENT opt_scrollable FOR EXECUTE 
-  {
-    return unimplemented(plpgsqllex, "cursor for execute")
-  }
-| OPEN IDENT opt_scrollable FOR stmt_until_semi ';'
-  {
-    stmts, err := parser.Parse($5)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    if len(stmts) != 1 {
-      return setErr(plpgsqllex, errors.New("expected exactly one SQL statement for cursor"))
-    }
-    $$.val = &plpgsqltree.Open{
-      CurVar: plpgsqltree.Variable($2),
-      Scroll: $3.cursorScrollOption(),
-      Query: stmts[0].AST,
-    }
-  }
-;
-
-stmt_fetch: FETCH
-  {
-    fetch, err := plpgsqllex.(*lexer).MakeFetchOrMoveStmt(false)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = fetch
-  }
-;
-
-stmt_move: MOVE
-  {
-    move, err := plpgsqllex.(*lexer).MakeFetchOrMoveStmt(true)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = move
-  }
-;
-
-stmt_close: CLOSE IDENT ';'
-  {
-    $$.val = &plpgsqltree.Close{CurVar: plpgsqltree.Variable($2)}
-  }
-;
-
-stmt_null: NULL ';'
-  {
-  $$.val = &plpgsqltree.Null{};
-  }
-;
-
-stmt_commit: COMMIT opt_transaction_chain ';'
-  {
-    return unimplemented(plpgsqllex, "commit")
-  }
-;
-
-stmt_rollback: ROLLBACK opt_transaction_chain ';'
-  {
-    return unimplemented(plpgsqllex, "rollback")
-  }
-;
-
-opt_transaction_chain:
-AND CHAIN
-  { }
-| AND NO CHAIN
-  { }
-| /* EMPTY */
-  { }
-
-exception_sect: /* EMPTY */
-  {
-    $$.val = []plpgsqltree.Exception(nil)
-  }
-| EXCEPTION proc_exceptions
-  {
-    $$.val = $2.exceptions()
-  }
-;
-
-proc_exceptions: proc_exceptions proc_exception
-  {
-    e := $2.exception()
-    $$.val = append($1.exceptions(), *e)
-  }
-| proc_exception
-  {
-    e := $1.exception()
-    $$.val = []plpgsqltree.Exception{*e}
-  }
-;
-
-proc_exception: WHEN proc_conditions THEN proc_sect
-  {
-    $$.val = &plpgsqltree.Exception{
-      Conditions: $2.conditions(),
-      Action: $4.statements(),
-    }
-  }
-;
-
-proc_conditions: proc_conditions OR proc_condition
-  {
-    c := $3.condition()
-    $$.val = append($1.conditions(), *c)
-  }
-| proc_condition
-  {
-    c := $1.condition()
-    $$.val = []plpgsqltree.Condition{*c}
-  }
-;
-
-proc_condition: any_identifier
-  {
-    $$.val = &plpgsqltree.Condition{SqlErrName: $1}
-  }
-| SQLSTATE SCONST
-  {
-    $$.val = &plpgsqltree.Condition{SqlErrState: $2}
-  }
-;
-
-expr_until_semi:
-  {
-    sqlStr, _, err := plpgsqllex.(*lexer).ReadSqlExpr(';')
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$ = sqlStr
-  }
-;
-
-stmt_until_semi:
-  {
-    sqlStr, _, err := plpgsqllex.(*lexer).ReadSqlStatement(';')
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$ = sqlStr
-  }
-;
-
-expr_until_then:
-  {
-    sqlStr, _, err := plpgsqllex.(*lexer).ReadSqlExpr(THEN)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$ = sqlStr
-  }
-;
-
-expr_until_loop:
-  {
-    sqlStr, _, err := plpgsqllex.(*lexer).ReadSqlExpr(LOOP)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$ = sqlStr
-  }
-;
-
-expr_until_paren :
-  {
-    sqlStr, _, err := plpgsqllex.(*lexer).ReadSqlExpr(')')
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$ = sqlStr
-  }
-;
-
-opt_block_label	:
-  {
-    $$ = ""
-  }
-| LESS_LESS any_identifier GREATER_GREATER
-  {
-    $$ = $2
-  }
-;
-
-opt_loop_label:
-  {
-    $$ = ""
-  }
-| LESS_LESS any_identifier GREATER_GREATER
-  {
-    $$ = $2
-  }
-;
-
-opt_label:
-  {
-    $$ = ""
-  }
-| any_identifier
-  {
-    $$ = $1
-  }
-;
-
-opt_exitcond: ';'
-  { }
-| WHEN expr_until_semi ';'
-  {
-    expr, err := plpgsqllex.(*lexer).ParseExpr($2)
-    if err != nil {
-      return setErr(plpgsqllex, err)
-    }
-    $$.val = expr
-  }
-;
-
-/*
- * need to allow DATUM because scanner will have tried to resolve as variable
- */
-any_identifier:
-IDENT
-| unreserved_keyword
-;
-
-unreserved_keyword:
-  ABSOLUTE
-| ALIAS
-| AND
-| ARRAY
-| ASSERT
-| BACKWARD
-| CALL
-| CHAIN
-| CLOSE
-| COLLATE
-| COLUMN
-| COLUMN_NAME
-| COMMIT
-| CONSTANT
-| CONSTRAINT
-| CONSTRAINT_NAME
-| CONTINUE
-| CURRENT
-| CURSOR
-| DATATYPE
-| DEBUG
-| DEFAULT
-| DETAIL
-| DIAGNOSTICS
-| DO
-| DUMP
-| ELSIF
-| ERRCODE
-| ERROR
-| EXCEPTION
-| EXIT
-| FETCH
-| FIRST
-| FORWARD
-| GET
-| HINT
-| IMPORT
-| INFO
-| INSERT
-| IS
-| LAST
-| LOG
-| MERGE
-| MESSAGE
-| MESSAGE_TEXT
-| MOVE
-| NEXT
-| NO
-| NO_SCROLL
-| NOTICE
-| OPEN
-| OPTION
-| PERFORM
-| PG_CONTEXT
-| PG_DATATYPE_NAME
-| PG_EXCEPTION_CONTEXT
-| PG_EXCEPTION_DETAIL
-| PG_EXCEPTION_HINT
-| PRINT_STRICT_PARAMS
-| PRIOR
-| QUERY
-| RAISE
-| RELATIVE
-| RETURN
-| RETURN_NEXT
-| RETURN_QUERY
-| RETURNED_SQLSTATE
-| REVERSE
-| ROLLBACK
-| ROW_COUNT
-| ROWTYPE
-| SCHEMA
-| SCHEMA_NAME
-| SCROLL
-| SLICE
-| SQLSTATE
-| STACKED
-| TABLE
-| TABLE_NAME
-| TYPE
-| UPSERT
-| USE_COLUMN
-| USE_VARIABLE
-| VARIABLE_CONFLICT
-| WARNING
-
-reserved_keyword:
-  ALL
-| BEGIN
-| BY
-| CASE
-| DECLARE
-| ELSE
-| END
-| END_CASE
-| END_IF
-| EXECUTE
-| FOR
-| FOREACH
-| FROM
-| IF
-| IN
-| INTO
-| LOOP
-| NOT
-| NULL
-| OR
-| STRICT
-| THEN
-| TO
-| USING
-| WHEN
-| WHILE
-
-%%
diff --git a/pkg/sql/scanner/plpgsql_scan.go b/pkg/sql/scanner/plpgsql_scan.go
deleted file mode 100644
index 3dc5500..0000000
--- a/pkg/sql/scanner/plpgsql_scan.go
+++ /dev/null
@@ -1,246 +0,0 @@
-// Copyright 2023 The Cockroach Authors.
-//
-// Use of this software is governed by the Business Source License
-// included in the file licenses/BSL.txt.
-//
-// As of the Change Date specified in that file, in accordance with
-// the Business Source License, use of this software will be governed
-// by the Apache License, Version 2.0, included in the file
-// licenses/APL.txt.
-
-package scanner
-
-import (
-	"fmt"
-	"go/constant"
-	"go/token"
-
-	sqllex "github.com/cockroachdb/cockroachdb-parser/pkg/sql/lexbase"
-	"github.com/cockroachdb/cockroachdb-parser/pkg/sql/plpgsql/parser/lexbase"
-)
-
-// PLpgSQLScanner is a scanner with a PLPGSQL specific scan function
-type PLpgSQLScanner struct {
-	Scanner
-}
-
-// Scan scans the next token and populates its information into lval.
-// This scan function contains rules for plpgsql.
-func (s *PLpgSQLScanner) Scan(lval ScanSymType) {
-	ch, skipWhiteSpace := s.scanSetup(lval)
-
-	if skipWhiteSpace {
-		return
-	}
-
-	switch ch {
-	case '$':
-		if s.scanDollarQuotedString(lval) {
-			lval.SetID(lexbase.SCONST)
-			return
-		}
-		return
-
-	case identQuote:
-		// "[^"]"
-		if s.scanString(lval, identQuote, false /* allowEscapes */, true /* requireUTF8 */) {
-			lval.SetID(lexbase.IDENT)
-		}
-		return
-
-	case singleQuote:
-		// '[^']'
-		if s.scanString(lval, ch, false /* allowEscapes */, true /* requireUTF8 */) {
-			lval.SetID(lexbase.SCONST)
-		}
-		return
-
-	case 'b':
-		// Bytes?
-		if s.peek() == singleQuote {
-			// b'[^']'
-			s.pos++
-			if s.scanString(lval, singleQuote, true /* allowEscapes */, false /* requireUTF8 */) {
-				lval.SetID(lexbase.BCONST)
-			}
-			return
-		}
-		s.scanIdent(lval)
-		return
-
-	case '.':
-		switch t := s.peek(); {
-		case t == '.': // ..
-			s.pos++
-			lval.SetID(lexbase.DOT_DOT)
-			return
-		case sqllex.IsDigit(t):
-			s.scanNumber(lval, ch)
-			return
-		}
-		return
-
-	case '!':
-		switch s.peek() {
-		case '=': // !=
-			s.pos++
-			lval.SetID(lexbase.NOT_EQUALS)
-			return
-		}
-		return
-
-	case '<':
-		switch s.peek() {
-		case '<': // <<
-			s.pos++
-			lval.SetID(lexbase.LESS_LESS)
-			return
-		case '=': // <=
-			s.pos++
-			lval.SetID(lexbase.LESS_EQUALS)
-			return
-		}
-		return
-
-	case '>':
-		switch s.peek() {
-		case '>': // >>
-			s.pos++
-			lval.SetID(lexbase.GREATER_GREATER)
-			return
-		case '=': // >=
-			s.pos++
-			lval.SetID(lexbase.GREATER_EQUALS)
-			return
-		}
-		return
-
-	case ':':
-		switch s.peek() {
-		case ':':
-			s.pos++
-			lval.SetID(lexbase.TYPECAST)
-			return
-		case '=':
-			s.pos++
-			lval.SetID(lexbase.COLON_EQUALS)
-			return
-		}
-		return
-
-	default:
-		if sqllex.IsDigit(ch) {
-			s.scanNumber(lval, ch)
-			return
-		}
-		if sqllex.IsIdentStart(ch) {
-			s.scanIdent(lval)
-			return
-		}
-	}
-	// Everything else is a single character token which we already initialized
-	// lval for above.
-}
-
-func (s *PLpgSQLScanner) scanNumber(lval ScanSymType, ch int) {
-	start := s.pos - 1
-	isHex := false
-	hasDecimal := ch == '.'
-	hasExponent := false
-
-	for {
-		ch := s.peek()
-		if (isHex && sqllex.IsHexDigit(ch)) || sqllex.IsDigit(ch) {
-			s.pos++
-			continue
-		}
-		if ch == 'x' || ch == 'X' {
-			if isHex || s.in[start] != '0' || s.pos != start+1 {
-				lval.SetID(lexbase.ERROR)
-				lval.SetStr(errInvalidHexNumeric)
-				return
-			}
-			s.pos++
-			isHex = true
-			continue
-		}
-		if isHex {
-			break
-		}
-		if ch == '.' {
-			if hasDecimal || hasExponent {
-				break
-			}
-			s.pos++
-			if s.peek() == '.' {
-				// Found ".." while scanning a number: back up to the end of the
-				// integer.
-				s.pos--
-				break
-			}
-			hasDecimal = true
-			continue
-		}
-		if ch == 'e' || ch == 'E' {
-			if hasExponent {
-				break
-			}
-			hasExponent = true
-			s.pos++
-			ch = s.peek()
-			if ch == '-' || ch == '+' {
-				s.pos++
-			}
-			ch = s.peek()
-			if !sqllex.IsDigit(ch) {
-				lval.SetID(lexbase.ERROR)
-				lval.SetStr("invalid floating point literal")
-				return
-			}
-			continue
-		}
-		break
-	}
-
-	lval.SetStr(s.in[start:s.pos])
-	if hasDecimal || hasExponent {
-		lval.SetID(lexbase.FCONST)
-		floatConst := constant.MakeFromLiteral(lval.Str(), token.FLOAT, 0)
-		if floatConst.Kind() == constant.Unknown {
-			lval.SetID(lexbase.ERROR)
-			lval.SetStr(fmt.Sprintf("could not make constant float from literal %q", lval.Str()))
-			return
-		}
-		lval.SetUnionVal(NewNumValFn(floatConst, lval.Str(), false /* negative */))
-	} else {
-		if isHex && s.pos == start+2 {
-			lval.SetID(lexbase.ERROR)
-			lval.SetStr(errInvalidHexNumeric)
-			return
-		}
-
-		// Strip off leading zeros from non-hex (decimal) literals so that
-		// constant.MakeFromLiteral doesn't inappropriately interpret the
-		// string as an octal literal. Note: we can't use strings.TrimLeft
-		// here, because it will truncate '0' to ''.
-		if !isHex {
-			for len(lval.Str()) > 1 && lval.Str()[0] == '0' {
-				lval.SetStr(lval.Str()[1:])
-			}
-		}
-
-		lval.SetID(lexbase.ICONST)
-		intConst := constant.MakeFromLiteral(lval.Str(), token.INT, 0)
-		if intConst.Kind() == constant.Unknown {
-			lval.SetID(lexbase.ERROR)
-			lval.SetStr(fmt.Sprintf("could not make constant int from literal %q", lval.Str()))
-			return
-		}
-		lval.SetUnionVal(NewNumValFn(intConst, lval.Str(), false /* negative */))
-	}
-}
-
-func (s *PLpgSQLScanner) scanIdent(lval ScanSymType) {
-	s.lowerCaseAndNormalizeIdent(lval)
-	lval.SetID(lexbase.GetKeywordID(lval.Str()))
-}
-- 
2.38.1

